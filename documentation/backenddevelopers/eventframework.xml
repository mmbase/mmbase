<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd">
<article class="specification">
  <!--
		This document is a template for a technical reference document.
		Use this document to explain :
		- the (use of) interfaces or vital classes in your project.
		- the properties in resources used by the project (other than for configuration)

		You only need a technical reference if the project goal is to provide a class structure that other developers need to add or expand MMBase functionality, or if it includes resources that developers are likely to change.
		Note that the description of resources needed for configuration should go in the configuration document.

		In the text below, replace the bracketed text with your own.
	-->

  <articleinfo>
    <title>The event framework</title>

    <date>2005-12-09</date>

    <edition>$Id: eventframework.xml,v 1.2 2005-12-12 21:15:54 andre Exp $</edition>

    <authorgroup>
      <!-- one or more authors -->

      <author>
        <firstname>Ernst</firstname>

        <surname>Bunders</surname>
      </author>
    </authorgroup>

    <revhistory>
      <revision>
        <revnumber>1.0</revnumber>

        <date>2005-12-09</date>

        <authorinitials>EB</authorinitials>

        <revremark>First version</revremark>
      </revision>
    </revhistory>

    <abstract>
      <para>Technical reference for [the new framework that was added as part
      of the queryResult cache release strategy project]</para>
    </abstract>

    <legalnotice>
      <para>This software is OSI Certified Open Source Software. OSI Certified
      is a certification mark of the Open Source Initiative.</para>

      <para>The license (Mozilla version 1.0) can be read at the MMBase site.
      See <ulink
      url="http://www.mmbase.org/license">http://www.mmbase.org/license</ulink></para>
    </legalnotice>

    <productnumber>from 1.8</productnumber>
  </articleinfo>

  <section id="introduction">
    <title>Introduction</title>

    <para>The introduction of a new event model is part of the query cache
    release strategy project. Because the current MMBase node events yield to
    little information for advanced query invalidation rules, we needed a more
    detailed node and relation change event. NodeEvent and RelationEvent
    objects were introduced to cover this.</para>
  </section>

  <section id="architecture">
    <title>Architecture</title>

    <para>The core of the system is the EventManager. A singleton instance of
    this class is instantiated at startup time. This event manager is being
    loaded with brokers for a number of (MMBase) events. These are: NodeEvent,
    RelationEvent, and Event (by means of the AllEventBroker, used by the
    clustering application). If you want MMBase to load other event brokers as
    well, add them to the cluster manager configuration file eventManager.xml
    in the config directory. The event manager manages the brokers (one for
    each event type), and accepts listeners for these event types, as well as
    events (of any supported type) to pass on to the brokers. The event
    manager tries to find an event broker for every listener that is
    registered with it, and passes it on to the broker (that actually manages
    the listeners for it's event type`). are So what happens when an event is
    fired? 1 some code calls EventManager.propagateEvent(Event event). All
    event classes need to extend from event, so it can be any event. 2 the
    event manager iterates over it's event brokers, and asks each one if it
    can broker for this event (which mean it can deliver it to the right
    listeners. 3 The event broker (a specialization of AbstractEventBroker)
    calls canBrokerForEvent(Event event), (one of AbstractEventBroker's
    abstract methods you have to override to create an actual broker) to
    discover if this event is for him. 4 if so, the broker iterates over it's
    listeners, and propagates the event.</para>

    <graphic fileref="media/eventframework.jpg" />
  </section>

  <section id="roll_your_own">
    <title>Roll your own event type</title>

    <para>It is easy to add your own type of event. These can be MMBase
    related events or events that are pertinent to some application/extension
    you created. The great bonus is that your events are delivered across your
    mmbase cluster.</para>

    <para>For every type of event you have to have two classes and one
    interface: an EventBroker, an Event and an EventListener interface.</para>

    <section id="create_Event">
      <title>Event</title>

      <para>Your event class has to extend org.mmbase.core.event.Event. This
      serves as a base type and also keeps track of the location in the
      cluster that the event originated from. One of the big advantages of
      using MMBase to send your application events is that they are send to
      all mmbase nodes in your network (that are configured to receive each
      others multicast messages), so it is more easy to write scalable web
      applications. (See for more information the document about mmbase
      clustering).</para>
    </section>

    <section id="create_EventListener">
      <title>EventListener</title>

      <para>The EventListener interface has to extend
      org.mmbase.core.event.EventListener. It has to define one method that
      will be called by your event broker. (so what ever method name you
      choose is up to you, just make sure it accepts an instance of your event
      object and your event broker calls it).</para>

      <para>Every class that wants to be notified of your type of event has to
      implement this interface and implement it's methods.</para>
    </section>

    <section id="create_EventBroker">
      <title>EventBroker</title>

      <para>First you need a broker for you event type. The function of an
      event broker is to manage all listeners for your event type. It also
      determines for the event manager if it can handle an event. Event
      brokers have to be registered with the event manager. This is all you
      have to do to make it accept listeners for your event type, and notify
      them.</para>

      <para>To create your own event broker simply extend AbstractEventBroker
      and implement the abstract methods. For an example it is a good idea to
      take a look ad NodeEventBroker.</para>
    </section>
  </section>

  <section>
    <title>NodeEvent and RelationEvent: what has changed</title>

    <para>This section contains information for people who just want to create
    listeners for node and relation events. This is usualy done when creating
    custom builder classes.</para>

    <para>Some things have changed in respect to the previous
    org.mmbase.module.core.MMBaseObserver. This interface provided different
    methods for local and remote node changes. It was felt that this is not
    very useful; the usual practice seems to be to create one method to handle
    both types of events. It is still possible to determine if an event was
    local or remote by comparing the machine name of the event to the local
    one.</para>

    <para>On the other hand is the information provided by the attributes of
    these methods very poor. This was the main motivation to change the event
    model.</para>

    <para>The new org.mmbase.core.event.NodeEventListener and
    org.mmbase.core.event.RelationEventListener interfaces create a
    distinction between node and relation events. The classes
    org.mmbase.core.event.NodeEvent and org.mmbase.core.event.RElationEvent
    (and through them the events) provide much more information than
    before.</para>

    <para>To make it as easy as it was before to register listeners to node
    and/or relation events of a specific builder, Some wrapper classes were
    created for NodeEventListener and RelationEventListener instances, that
    will filter the events for you (take a look at
    org.mmbase.core.event.TypedNodeEventListenerWrapper and
    org.mmbase.core.event.TypedRelationEventListenerWrapper. But you don't
    even have to use those directly. Both the MMBase and MMObjectBuilder
    classes have convenience methods to register your listeners. Take a look
    at Mmbase.addNodeRelatedEventsListener(String builder, Object listener)
    and MMObjectBuilder.addEventListener(Object listener). The object is your
    class implementing either NodeEventListener or RelationeventListener or
    both (discovered through introspection). Wrappers are created accordingly
    and registered as listeners.</para>
  </section>
</article>
