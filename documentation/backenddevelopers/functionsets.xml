<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd">
<article>
  <articleinfo>
    <title>The MMBase Function Framework</title>

    <date>2006-07-07</date>

    <edition>$Id: functionsets.xml,v 1.7 2006/06/24 08:38:04 michiel Exp
    $</edition>

    <authorgroup>
      <author>
        <firstname>Daniel</firstname>

        <surname>Ockeloen</surname>

        <affiliation>
          <orgname>MMCoder</orgname>
        </affiliation>
      </author>

      <author>
        <firstname>Andr√©</firstname>

        <surname>van Toly</surname>
      </author>

      <author>
        <firstname>Michiel</firstname>

        <surname>Meeuwissen</surname>
      </author>
    </authorgroup>

    <legalnotice>
      <para>This software is OSI Certified Open Source Software. OSI Certified
      is a certification mark of the Open Source Initiative.</para>

      <para>The license (Mozilla version 1.0) can be read at the MMBase site.
      See <ulink
      url="http://www.mmbase.org/license">http://www.mmbase.org/license</ulink></para>
    </legalnotice>
  </articleinfo>

  <section id="whatare">
    <title>What are functions ?</title>

    <para>The MMBase 'Function Framework' allows you to add functions or
    methods to different layers of MMBase. You can access them using the
    taglib function tags or the bridge. Functions can be added to nodes,
    builders and clouds and can be defined in three locations:</para>

    <itemizedlist>
      <listitem>
        <para>The nodemanager (or builder) of a certain nodetype</para>

        <para>These functions are methods in the Java code belonging to a
        builder. Some examples of such functions these can be found in
        org.mmbase.util.functions.ExampleBuilder.</para>
      </listitem>

      <listitem>
        <para>As a functionset</para>

        <para>A functionset are functions which are grouped together in a set.
        Normally such a set belongs to one application. With it developers can
        make rather complicated functionality available to templaters.
        Functionsets are defined in
        'config/functions/functionsets.xml'.</para>
      </listitem>

      <listitem>
        <para>A specific classname</para>

        <para>It is also possible to directly acces a specific method in a JSP
        using the function tags. See for example
        org.mmbase.util.functions.ExampleBean</para>
      </listitem>
    </itemizedlist>

    <para>Each having their own backend implementation but they all share a
    common way to use them from inside Java or JSP. This document shows some
    examples of the use of functions, more information can be found in the API
    documentation at org.mmbase.util.functions and the taglib reference
    documentation.</para>
  </section>

  <section id="taglib">
    <title>Some simple examples with the MMBase taglib</title>

    <para>Allmost everybody who is bit familiar with the MMBase taglib knows
    that you can get the gui value of a node with a few simple lines of
    code.</para>

    <programlisting>&lt;mm:node number="default.mags"&gt;
  &lt;mm:field name="gui()" /&gt;
&lt;/mm:node&gt;</programlisting>

    <para>This functionality is deprecated. The equivalent method of getting
    the gui value of a node is the following and as such is method defined in
    MMObjectbuilder.</para>

    <!--is that true?-->

    <programlisting>&lt;mm:node number="default.mags"&gt;
  &lt;mm:function name="gui" /&gt;
&lt;/mm:node&gt;</programlisting>

    <para>Another simple example of a function is made available by the class
    org.mmbase.util.functions.ExampleBean and could look like this. It
    accesses the method stringFunction which uses no arguments and returns an
    arbitrary String.</para>

    <programlisting>&lt;mm:function classname="org.mmbase.util.functions.ExampleBean" name="stringFunction" /&gt;</programlisting>

    <para>ExampleBean contains multiple methods that can be accessed using
    functions, but when you would strip down ExampleBean to the bare minimum
    that is needed to execute the above example you will be left with the
    following lines of code.</para>

    <programlisting>package org.mmbase.util.functions;

    public final class ExampleBean {
    private String parameter1;
    private String parameter3 = "default";

    public void setParameter1(String hoi) {
        parameter1 = hoi;
    }

    public void setAnotherParameter(String a) {
        parameter3 = a;
    }

    public String stringFunction() {
        return "[[" + parameter1 + "/" + parameter3 + "]]";
    }

}
</programlisting>

    <para>As you would expect the combined examples return '[[null/default]]'.
    A more exiting example would use the the set-methods defined in this bean
    by using parameter tags which should be grouped using the
    functioncontainer tag.</para>

    <programlisting>  &lt;mm:functioncontainer&gt;
    &lt;mm:param name="parameter1"&gt;foo&lt;/mm:param&gt;
    &lt;mm:param name="anotherParameter"&gt;bar&lt;/mm:param&gt;
    &lt;mm:function classname="org.mmbase.util.functions.ExampleBean" name="stringFunction" /&gt;
  &lt;/mm:functioncontainer&gt; </programlisting>

    <para>The above example returns '[[foo/bar]]'.</para>
  </section>

  <section id="returntypes">
    <title>Function tag return types and parameters</title>

    <para>The class ExampleBean has several examples all with different return
    types. Multiple return types are defined by the way you call them. The
    taglib contains the following function tags to accommodate them.
    <programlisting>  &lt;mm:function          (String)
  &lt;mm:booleanfunction   (boolean)
  &lt;mm:voidfunction      (no return value)
  &lt;mm:listfunction      (list)
  &lt;mm:nodefunction      (a MMBase node or a virtual MMBase node)
  &lt;mm:nodelistfunction  (a list of nodes or virtual nodes)</programlisting></para>

    <para>Functions can have parameters. The functioncontainer tag is designed
    to group functions and parameters. It also provides you with a way to
    group several functions together. <programlisting>  &lt;mm:functioncontainer&gt;
    &lt;mm:param name="template"&gt;AASSHHM&lt;/mm:param&gt;
    your random new password might be : &lt;mm:function set="util" name="generatePassword" /&gt;
  &lt;/mm:functioncontainer&gt;  </programlisting></para>

    <para>Each of the defined parameters will be added to every function
    within the functioncontainer. </para>

    <para>It is also possible to add parameters using MMBase referids, this
    can come in handy when a variable is already present in your page and you
    want to access it. <programlisting>  &lt;mm:import externid="template"&gt;AASSHHM&lt;/mm:param&gt;
  Your random new password might be:  
  &lt;mm:function name="getPassword" referid="template" /&gt;         </programlisting></para>
  </section>

  <section id="bridge">
    <title>Using functions from the bridge</title>

    <para>The classes and interfaces of the function framework are in the
    org.mmbase.util.functions package. The bridge classes will return object
    from this package.</para>

    <para>The most important classes are 'Function', and 'Parameters'.</para>

    <para>The Function object represents the piece of functionality. You must
    start by somehow getting a Function object. Several bridge objects like
    Node, NodeManager and Module have their 'getFunction' methods, but you can
    also call the static methods from FunctionFactory from the
    org.mmbase.util.functions package.</para>

    <para>The most important methods of the function object are
    'createParameters' and 'getFunctionValue(Parameters)'. You'd normally
    start with calling 'createParameters': <programlisting>  
        Function nodeFunction = node.getFunction("myfunction");
        Parameters parameters = nodeFunction.createParameters();
      </programlisting> And then you have to set the parameters:
    <programlisting>
        parameters.set("foo", "bar");
        parameters.set(Parameter.REQUEST, request);
      </programlisting> You can only set parameters wich are defined for the
    function. Failing to do that results in exceptions. You can also fill this
    parameters object as a List (because it is a list). So you could have done
    this too: <programlisting>
        parameters.add("bar");
        parameters.add(request);
      </programlisting> or <programlisting>
        parameters.set(0, "bar");
        parameters.set(1, request);
      </programlisting> but then you have to remember the exact order of the
    parameters. It is recommended to set them by name.</para>

    <para>When ready, you can obtain the function value: <programlisting>
        Object value = function.getFunctionValue(parameters);
      </programlisting></para>

    <para>If the function does not need any parameters, you can skip the
    parameters part and simply provide null to getFunctionValue.</para>

    <section id="parameter">
      <title>Parameter</title>

      <para>The 'Parameter' class of org.mmbase.util.functions defines one
      parameter. So, it contains e.g. a name, a type and a default value.
      Don't be confused with the 'Parameters' class, which contains actual
      parameter <emphasis>values</emphasis>. A complete argument definition is
      represented with an <emphasis>array</emphasis> of Parameter
      objects.</para>

      <para>Many functions have similar arguments. Like 'cloud', 'request' or
      'locale'. For these kind of parameters some static constants in the
      Parameter class are present. These constants can be used to deal with
      parameters object without knowing very much about it. You can e.g. fill
      a cloud parameter if there is one: <programlisting>
        if (parameters.containsParameter(Parameter.CLOUD)) {
          parameters.set(Parameter.CLOUD, cloud);
        }
      </programlisting> or: <programlisting>
        parameters.setIfDefined(Parameter.CLOUD, cloud);
      </programlisting></para>

      <para>This is e.g. used by MMBase taglib to automaticly set some
      parameters (like cloud, request, node etc).</para>
    </section>
  </section>

  <section id="defining">
    <title>Defining functions in Builders for functions on builders and
    nodes</title>

    <para>For functions related to one type of nodes you can add functions its
    builder, they can be executed on either one node of on the builder itself.
    You can define them in 2 ways. One if in the builder.xml and the other is
    in the java file of the builder itself. From the example in
    tests/config/builders/tests/datatypes.xml <programlisting>
        &lt;functionlist&gt;
         &lt;function key="integerFunction" name="aaa"&gt;
            &lt;class&gt;org.mmbase.util.functions.ExampleBean&lt;/class&gt;
         &lt;/function&gt;
        &lt;/functionlist&gt;
     </programlisting></para>

    <para>Here we defined a function on the datatypes builder with the name
    'aaa', When this is called from either the bridge of tags it calls the
    integerFunction in the org.mmbase.util.functions.ExampleBean.
    <programlisting>
        public Integer integerFunction() {
                return new Integer(parameter2.intValue() * 3);
        }
    </programlisting></para>
  </section>

  <section id="modules">
    <title>Defining functions in Modules</title>

    <para>Its also possible to define functions in MMBase Modules see e.g. the
    MMAdmin module and its jsp pages in mmbase/mmadmin/. Also e.g. the crontab
    and clustering applications ship with modules (CrontabModule,
    ClusteringModule), which define 'functions' which are used in admin
    pages.</para>
  </section>

  <section id="sets">
    <title>Defining functions in Sets</title>

    <para>Unlike Module or NodeManagers related functions the set functions
    are aimed for a global use and can be implemented in any java class or .
    You can for example define a set 'util' or 'statistics' or even map to
    external application 'lucene'. Defining sets is done in a 2 xml files. The
    first defines what sets you have : <programlisting>
     mmbase config xml : config/functions/functionsets.xml

        &lt;functionsets&gt;
          &lt;functionset name="util" file="utils.xml" /&gt;
         &lt;/functionsets&gt;
     </programlisting> The set itself (in this case utils.xml) defines the
    mapping, names, classes and methods to be called <programlisting>
                &lt;functionset&gt;
                &lt;description&gt;Some util functions from org.mmbase.util, made accessible through the function-framework&lt;/description&gt;
                 &lt;function name="generatePassword"&gt;
                  &lt;description&gt;Generates a password. Using a template&lt;/description&gt;
                  &lt;type&gt;class&lt;/type&gt;
                  &lt;class&gt;org.mmbase.util.PasswordGenerator&lt;/class&gt;
                  &lt;method&gt;getPassword&lt;/method&gt;
                  &lt;param name="template" type="String"&gt;SSSSSS&lt;/param&gt;
                  &lt;return type="String" /&gt;
                 &lt;/function&gt;
                &lt;/functionset&gt;
     </programlisting></para>

    <para>In this example we only defined one function called
    generatePassword, its implemented as a class (type) the class file is
    (org.mmbase.util.PasswordGenerator) and the method that will be called
    inside that class is getPassword. Next we can define one or more
    parameters in this case one so the end result will be of this function
    configuration will be that &lt;mm:function set="util" name="getPassword"
    referid="template" /&gt; will be mapped to the method String
    getPassword(String template) inside the class
    org.mmbase.util.PasswordGenerator.</para>
  </section>

  <section id="lists">
    <title>Working with nodes and and nodelists</title>

    <para>One of the advantages of the function framework is that you can not
    only return objects like booleans or strings but also MMBase nodes or
    lists of nodes. In this way you can make function that work like a
    &lt;mm:node or &lt;mm:nodelist but have their own selection method. For
    example we could make a function like : <programlisting>
            &lt;mm:functionnode set="util" name="getRandomNode"&gt;
                object number : &lt;mm:field name="number" /&gt;
                object type : &lt;mm:field name="otype" /&gt;
                object owner : &lt;mm:field name="owner" /&gt;
        &lt;/mm:functionnode&gt;
    </programlisting> In the java code you just return a bridge or core node
    like <programlisting>
            public MMObjectNode getRandomNode() {
                return cloud.getRandomNode(randomnumber); // none working code
        }
    </programlisting></para>

    <para>The same is possible with lists : <programlisting>
             &lt;mm:functionnodelist set="util" name="getRandomNodes"&gt;
                object number : &lt;mm:field name="number" /&gt;
                object type : &lt;mm:field name="otype" /&gt;
                object owner : &lt;mm:field name="owner" /&gt;
             &lt;/mm:functionnodelist&gt;
     </programlisting> Again in java the method could look like this :
    <programlisting>
       public List getRandomNodes() {
                List list =  new ArrayList();
                list.add(cloud.getRandomNode(randomnumber)); // none working code
                list.add(cloud.getRandomNode(randomnumber2)); // none working code
                list.add(cloud.getRandomNode(randomnumber3)); // none working code
                return list;
        }
     </programlisting></para>

    <para>Its also possible to use virtual nodes in functions, this opens up a
    interesting uses in that it allows you to return any information in the
    form of mmbase objects. The main advantage of this that the frontend
    programmers can use the tools they already know for handling nodes, fields
    and lists for example we could return some information as a mmbase node
    like this : <programlisting>
            public MMObjectNode getOSInfo() {
                Cloud cloud = LocalContext.getCloudContext().getCloud("mmbase");
                MMObjectNode virtual = builder.getNewNode("admin");
                virtual.setValue("hardware", System.getProperty("os.arch");
                virtual.setValue("os", System.getProperty("os.name");
                virtual.setValue("version", System.getProperty("os.version");
                return virtual;
        }
    </programlisting> We can use this from the taglibs like we do with normal
    nodes <programlisting>
            &lt;mm:nodefunction set="mySet" name="getOSInfo"&gt;
                So you use &lt;mm:field name="hardware" /&gt;
                &lt;mm:field name="os"&gt;
                        &lt;mm:compare value="osx"&gt;
                                and i guess you don't like Bill Gates.
                        &lt;/mm:compare&gt;
                        &lt;mm:compare value="windowsxp"&gt;
                                and i guess you don't like Steve Jobs.
                        &lt;/mm:compare&gt;
                &lt;/mm:field&gt;
        &lt;/mm:nodefunction&gt;
     </programlisting></para>

    <para>We can also use this for lists for example we could make a list of
    accounts from a ldap server that acts like any normal mmbase list (made up
    code for the ldap parts). <programlisting>
            public List getAccounts(String searchkey) {
                Cloud cloud = LocalContext.getCloudContext().getCloud("mmbase");
                List list =  new ArrayList();
                // fill the list from the ldap server, using a while
                Iterator i = ldap.getAccounts(searchkey);
                while (i.hasNext()) {
                        NextLDAP user = (NextLDAP)i.next();
                        MMObjectNode virtual = builder.getNewNode("admin");
                        virtual.setValue("account", user.getAccount();
                        virtual.setValue("firstname", user.getFirstName();
                        virtual.setValue("surname", user.getSurName();
                        list.add(virtual);
                }
       }
    </programlisting> From the taglib we can work with this list like we can
    work with any other nodelist : <programlisting>
            &lt;mm:nodelistfunction set="mySet" name="getUsers" referid="searchkey"&gt;
                &lt;mm:first&gt;The first user found&lt;/mm:first&gt;
                &lt;mm:last&gt;The last user found&lt;/mm:last&gt;
                &lt;mm:field name="account" /&gt; (&lt;mm:field name="firstname" /&gt; &lt;mm:field name="surname" /&gt;)&lt;br /&gt;
        &lt;/mm:nodelistfunction&gt;
    </programlisting> As you can see all the normal mmbase tags can be
    applied, The frontend programmer doesn't have to know the content is not
    coming from mmbase at all.</para>
  </section>
</article>