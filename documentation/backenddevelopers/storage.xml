<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd">
<article class="specification">
  <articleinfo>
    <title>The Storage Layer</title>

    <date>6 July 2003</date>

    <edition>$Id: storage.xml,v 1.5 2003-07-01 10:06:38 pierre Exp $</edition>

    <authorgroup>
      <author>
        <firstname>Pierre</firstname>
        <surname>van Rooden</surname>
      </author>
    </authorgroup>

    <legalnotice>
      <para>This software is OSI Certified Open Source Software. OSI Certified
      is a certification mark of the Open Source Initiative.</para>

      <para>The license (Mozilla version 1.0) can be read at the MMBase site.
      See <ulink url="http://www.mmbase.org/license">http://www.mmbase.org/license</ulink></para>
    </legalnotice>
  </articleinfo>

  <section id="introduction">
    <title>Introduction</title>
		<para>TODO: intro</para>
  </section>
	
  <section id="interfaces">
    <title>Interfaces</title>
		<para>TODO: explain packages and interfaces</para>
		<note><para> It may be useful to drop the interfaces and use abstract classes instead.</para></note>
		<section id="Transaction">
			<title>Transaction Interface</title>
			<para>The Transaction object is used as a means to maintain state information regarding a transaction.</para>
			<para>A transaction comprises of all storage commands between creating (opening) a transaction object, and either closing or cancelling the transaction. In databases implementations, a Transaction is equal to a database connection (a <link linkend="DatabaseTransaction">DatabaseTransaction</link> is an implementation of Transaction, which defines several additional methods so database commands can be passed through the Transaction). In other storages, it could hold a reference to a temporary file, or a memory-based cache.</para>
			<para>The intention of the Transaction object is to allow - for those implementations that can - to roll back changes when the transaction fails. To do this, you need to pass the Transaction object to each and every method called in the storage layer. Once all changes have been made, you can make the changes permanent by committing the transaction.</para>
			<note><para>Using a Transaction by no means guarantees rollback is possible, as not all implementations will allow for rollback. You can check whether rollback is supported by calling the <methodname>supportsRollback()</methodname> method.</para></note>
			<programlisting format="linespecific"><![CDATA[
public interface Transaction {

	public boolean supportsRollback();

	public boolean commit();

	public boolean rollback();

}]]></programlisting>
			<formalpara>
				<title>Transaction Methods:</title>
				<para><variablelist>
						<varlistentry>
							<term><methodname>boolean supportsRollback();</methodname></term>
							<listitem>
								<para>This method returns <constant>true</constant> if the transaction object supports rollback.</para>
								<note><para>This method generally retrieves it's data by calling the <methodname>supportsRollback</methodname> method of the Storage class. Useful for when you do not have a reference to Storage, but otherwise a bit superfluous. However it is possible for individual transactions to turn rollback on or off (i.e. when querying data, rollback may be turned off as it makes the transaction quicker), so this method may still yield different results.</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>boolean commit();</methodname></term>
							<listitem>
								<para>This method closes the transaction and commits all changes. The method returns <constant>true</constant> if all goes well, and <constant>false</constant> if, for some reason, committing or closing fails.</para>
								<para>You should call this method only after all changes for this transaction have been made. The commit() actually closes the transaction (i.e. it closes the database connection), making it inaccessible after the call. Any further attempts to use the Transaction will throw a StorageException.</para>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>boolean rollback();</methodname></term>
							<listitem>
								<para>This method cancels the transaction. If the transaction supports rollback, all changes made to the storage through the transaction are undone. The method returns <constant>true</constant> if all goes well, and <constant>false</constant> if, for some reason, cancelling fails.</para>
								<para>You should call not use the transaction any more after this method is called, as, similar to commit, it closes the transaction and makes it inaccessible, so any further use will throw a StorageException.</para>
							</listitem>
						</varlistentry>
					</variablelist></para>
			</formalpara>
		</section>
	
		<section id="Storage">
			<title>Storage Interface</title>
			<para>The Storage interface defines a storage device - a location where MMBase objects are kept. This is generally a persistent layer, and most often a database. However, the way Storage is defined, when combined with th Query interface (not yet integrated in the interface) it is possible to create alternate storages, such as a memory-only storage for test purposes, or a xml-based storage.</para>
			<para>The interface defines methods for querying the storage, and for the creation, deletion, and updates of objects in the storage. It also defines method for creating or altering the storage itself (adding fields to a builder, for instance).</para>
			<para>The aim is to keep the storage free from database- or system-specific elements.</para>
			<para>Storage uses Transaction objects to track changes. With the exception of storage-altering methods, all methods in Storage accept a Transaction object as a parameter.</para>
			<programlisting format="linespecific"><![CDATA[
public interface Storage extends SearchQueryHandler {

	public boolean isAllowedParentBuilder(MMObjectBuilder builder);

	public void registerParentBuilder(MMObjectBuilder parent, MMObjectBuilder child) throws StorageException;

	public boolean supportsRollback();

	public String getText(MMObjectNode node,String fieldname);

	public byte[] getBytes(MMObjectNode node,String fieldname);

	public Transaction createTransaction() throws StorageException;

	public int createKey();

	public int createKey(Transaction trans) throws StorageException;

	public int insert(MMObjectNode node);

	public int insert(MMObjectNode node, Transaction trans) throws StorageException;

	public boolean commit(MMObjectNode node);

	public boolean commit(MMObjectNode node, Transaction trans) throws StorageException;

	public boolean delete(MMObjectNode node);

	public boolean delete(MMObjectNode node, Transaction trans) throws StorageException;

	public MMObjectNode getNode(MMObjectBuilder builder, int number);

	public MMObjectNode getNode(MMObjectBuilder builder, int number, Transaction trans) throws StorageException;

	public int getNodeType(int number);

	public int getNodeType(int number, Transaction trans) throws StorageException;

	public boolean create(MMObjectBuilder builder);

	public boolean create(MMObjectBuilder builder, Transaction trans) throws StorageException;

	public boolean createObjectStorage();

	public boolean createObjectStorage(Transaction trans) throws StorageException;

	public boolean created(MMObjectBuilder builder);

	public int size(MMObjectBuilder builder);

	public boolean drop(MMObjectBuilder builder);

	public boolean addField(MMObjectBuilder builder,String fieldname);

	public boolean removeField(MMObjectBuilder builder,String fieldname);

	public boolean changeField(MMObjectBuilder builder,String fieldname);

	public boolean updateStorage(MMObjectBuilder builder);

}]]></programlisting>
			<formalpara>
				<title>Storage Methods:</title>
				<para><variablelist>
						<varlistentry>
							<term><methodname>boolean isAllowedParentBuilder(MMObjectBuilder builder);</methodname></term>
							<listitem>
								<para>Returns whether this storage layer allows for the specified builder to be a parent builder (that is, other builders can 'extend' this builder and its storage device). 'Object' and 'Insrel' should always be allowed parent builders. Whether other builders are allowed depends on the storage implementation (which may or may not implement means for builder tables to extend each other).</para>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>void registerParentBuilder(MMObjectBuilder parent, MMObjectBuilder child)
					throws StorageException;</methodname></term>
							<listitem>
								<para>Registers a builder as a parent builder (that is, other builders can 'extend' this builder and its storage device). At the least, this code should check whether the builder is allowed as a parent builder, and throw an exception if this is not possible.</para>
								<note><para>This method will be dropped from the interface. Knowledge on whether a builder extends other builders should be done in the builder itself, not in the storage layer. In current implementations the method does not do anything useful anyway.</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>boolean supportsRollback();</methodname></term>
							<listitem>
								<para>Returns whether rollback on storage level is supported. This method determines whether <link linkend="Transaction" >Transaction</link> objects for this layer can rollback changes. If <methodname>Storage.supportsRollback()</methodname> returns false, the <methodname>Transaction.supportsRollback()</methodname> should also return false.</para>
							</listitem>
						</varlistentry>
						
						<varlistentry>
							<term><methodname>String getText(MMObjectNode node,String fieldname);</methodname></term>
							<listitem>
								<para>Retrieve a large text for a specified object field. While this would normally be retrieved using getNode(), for purposes of performance and memory preservation, you might not want to load large texts in memory until you actually uses this. If you want to preserve memory in your storage, you can implement this method to return texts on demand. In addition, when you assemble a Node from storage, you will need to fill the text fields that you do NOT want to load directly with an indicator value (currently the text "$SHORTED").
								</para>
								<note><para>It may be useful to define a specific Indicator object/value rather than a text. The Indicator object would need to be defined in the Storage Interface.</para></note>
								<note><para>There should be a Transactional version of this method.</para></note>
							</listitem>
						</varlistentry>
						
						<varlistentry>
							<term><methodname>byte[] getBytes(MMObjectNode node,String fieldname);</methodname></term>
							<listitem>
								<para>Retrieve a large binary object (byte array) for a specified object field. See getText() above for more details. The Indicator for an unloaded Binary field is the same as for an unloaded text field.</para>
								<note><para>There should be a Transactional version of this method.</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>Transaction createTransaction() throws StorageException;</methodname></term>
							<listitem>
								<para>Returns a newly created <link linkend="Transaction" >Transaction</link> object. The Transaction object should be passed to most transaction-sensitive Storage methods (such as delete(), create(), etc). Note that most 'non-transactional' methods will actually create and use a transaction (though invisible to those outside the Storage class).</para>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>int createKey();</methodname></term>
							<listitem><para>Gives an unique number for a node to be inserted. This method is non-transactional (does not require a Transaction object), and should work properly even if multiple mmbase servers use the same storage. Currently this method actually calls the transactional version of the createKey method, but that method will be dropped. </para>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>int createKey(Transaction trans) throws StorageException;</methodname></term>
							<listitem>
								<para>Gives an unique number for a node to be inserted, using the given Transaction to access the Storage. This method should work properly even if multiple mmbase servers use the same storage.</para>
								<note><para>Since obtaining a key should work cross- server, it should also work cross-transaction. Using a transaction to obtain the key does not actually add functionality. This method will be dropped, unless merits can be found to trace the Transaction that created the key.</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>int insert(MMObjectNode node);</methodname></term>
							<listitem>
								<para>This method inserts a new object, and registers the change. Only fields with states of DBSTATE_PERSISTENT or DBSTATE_SYSTEM are stored. This method is non-transactional. Standard implementation creates a Transaction, calls the transactional version of this method, and returns a new node number or -1 depending on success.</para>
								<note><para>We should determine whether non-transactional methods should be included in the Interface. While it is useful as it simplifies calls to Storage, it also complicates the interface. It should be determined whether these methods are to be included in the Storage interface or not. Alternate solutions are to create a TransactionalStorage interface and move all transactional versions of methods there, or to simply drop the non-transactional methods from Storage and - for backward compatibility -include them in the Support2Storage class. This notice applies to all transactional methods, including <methodname>commit</methodname>, <methodname>delete</methodname>, <methodname>create</methodname>, <methodname>getNode</methodname>, <methodname>getNodeType</methodname>, and <methodname>createObjectStorage</methodname>. It may also be worthwhile to add the transactional methods to the Transaction interface, so that Transaction.insert(MMObjectNode) will be similar to Storage.insert(MMObjectNode, Transaction).</para></note>
								<note><para>It should be considered to rename <methodname>insert()</methodname> to <methodname>createNode()</methodname></para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>int insert(MMObjectNode node, Transaction trans) throws StorageException;</methodname></term>
							<listitem>
								<para>This method inserts a new object within a transaction, and registers the change.</para>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>boolean commit(MMObjectNode node);</methodname></term>
							<listitem>
								<para>Commit this node to the specified builder. This method is non-transactional. Standard implementation creates a Transaction, calls the transactional version of this method, and returns true if successful, false if an error occurred</para>
								<note><para>See insert() for notes on non-transactional method.</para></note>
								<note><para>It should be considered to rename <methodname>commit()</methodname> to <methodname>commitNode()</methodname></para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>boolean commit(MMObjectNode node, Transaction trans) throws StorageException;</methodname></term>
							<listitem>
								<para>Commit this node to the specified builder within a transaction.</para>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>boolean delete(MMObjectNode node);</methodname></term>
							<listitem>
								<para>Delete a node. This method is non-transactional. Standard implementation creates a Transaction, calls the transactional version of this method, and returns true if successful, false if an error occurred</para>
								<note><para>See insert() for notes on non-transactional method.</para></note>
								<note><para>It should be considered to rename <methodname>delete()</methodname> to <methodname>deleteNode()</methodname></para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>boolean delete(MMObjectNode node, Transaction trans) throws StorageException;</methodname></term>
							<listitem>
								<para>Delete a node within a transaction.</para>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>MMObjectNode getNode(MMObjectBuilder builder, int number);</methodname></term>
							<listitem>
								<para>Select a node from a specified builder. This method is non-transactional. Standard implementation creates a Transaction, calls the transactional version of this method, and returns true if successful, false if an error occurred.</para>
								<note><para>Changes in other transactions may - depending on implementation - not be visible when using this method.</para></note>
								<note><para>See insert() for notes on non-transactional method.</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>MMObjectNode getNode(MMObjectBuilder builder, int number, Transaction trans) throws StorageException;</methodname></term>
							<listitem>
								<para>Select a node from a specified builder within a transaction. This method guarantees to incorporate any changes made during the transaction.</para>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>int getNodeType(int number);</methodname></term>
							<listitem>
								<para>Returns the nodetype for a specified node number. This method is non-transactional. Standard implementation creates a Transaction, calls the transactional version of this method, and returns true if successful, false if an error occurred.</para>
								<note><para>Changes in other transactions may - depending on implementation - not be visible when using this method.</para></note>
								<note><para>See insert() for notes on non-transactional method.</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>int getNodeType(int number, Transaction trans) throws StorageException;</methodname></term>
							<listitem>
								<para>Returns the nodetype for a specified nodereference within a transaction. This method guarantees to incorporate any changes made during the transaction.</para>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>boolean create(MMObjectBuilder builder);</methodname></term>
							<listitem>
								<para>This method is non-transactional. Standard implementation creates a Transaction, calls the transactional version of this method, and returns true if successful, false if an error occurred</para>
								<note><para>See insert() for notes on non-transactional method, but see also the transactional method.</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>boolean create(MMObjectBuilder builder, Transaction trans) throws StorageException;</methodname></term>
							<listitem>
								<para>Create a storage for the specified builder within a transaction.</para>
								<note><para>I don't think defining a storage (creating, deleting, or altering it) should be done within a transaction (as it generally works on database tables). It seems more useful to only define this method as non-transactional, so that calling this method assures the storage is there, so that when you use multiple servers you will not run into conflict (or use functionality that may not be there). This also counts for <methodname>createObjectStorage</methodname>, <methodname>addField</methodname>, <methodname>removeField</methodname>, <methodname>ChangeField</methodname>, and <methodname>updateStorage</methodname>.</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>boolean createObjectStorage();</methodname></term>
							<listitem>
								<para>Create the object storage (the storage where to register all objects).</para>
								<note><para>See insert() and create() for notes on non-transactional vs transactional method.</para></note>
								<note><para>It should be considered to rename <methodname>createObjectStorage()</methodname> to <methodname>createStorage()</methodname></para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>boolean createObjectStorage(Transaction trans) throws StorageException;</methodname></term>
							<listitem>
								<para>Create the object storage (the storage where to register all objects) within a transaction.</para>
								<note><para>See create() for notes on transactional methods pertaining the creation of storages.</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>boolean created(MMObjectBuilder builder);</methodname></term>
							<listitem>
								<para>Tells if a storage for the builder already exists.</para>
								<note><para>There is currently no non-transactional method for created(). Whether there should be one is dependent on whether the transactional method for create() is dropped or not.</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>int size(MMObjectBuilder builder);</methodname></term>
							<listitem>
								<para>Return the number of objects in a builder.</para>
								<note><para>Should have a transactional version, as transactional methods can affect the size of builder.</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>boolean drop(MMObjectBuilder builder);</methodname></term>
							<listitem>
								<para>Drops the storage of this builder.</para>
								<note><para>There is currently no non-transactional method for drop(). Whether there should be one is dependent on whether the transactional method for create() is dropped or not.</para></note>
								<note><para>It should be considered to rename <methodname>drop()</methodname> [database specific] to <methodname>delete()</methodname></para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>boolean addField(MMObjectBuilder builder,String fieldname);</methodname></term>
							<listitem>
								<para>Adds a field to the storage of this builder.</para>
								<note><para>See <methodname>create()</methodname> for suggestions on transactional methods that create/define storage.</para></note>
								<note><para>Should be renamed to <methodname>createField()</methodname> (in accordance with code conventions)</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>boolean removeField(MMObjectBuilder builder,String fieldname);</methodname></term>
							<listitem>
								<para>Deletes a field from the storage of this builder.</para>
								<note><para>See <methodname>create()</methodname> for suggestions on transactional methods that create/define storage.</para></note>
								<note><para>Should be renamed to deleteField (in accordance with code conventions)</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>boolean changeField(MMObjectBuilder builder,String fieldname);</methodname></term>
							<listitem>
								<para>Changes a field to the storage of this builder.</para>
								<note><para>See <methodname>create()</methodname> for suggestions on transactional methods that create/define storage.</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>boolean updateStorage(MMObjectBuilder builder);</methodname></term>
							<listitem>
								<para>Changes the storage of a builder to match its new configuration.</para>
								<note><para>See <methodname>create()</methodname> for suggestions on transactional methods that create/define storage.</para></note>
							</listitem>
						</varlistentry>
					</variablelist></para>
			</formalpara>
		</section>
		
		<section id="DatabaseStorage">
			<title>DatabaseStorage Interface</title>
			<para>...</para>
			<programlisting format="linespecific"><![CDATA[
	public interface DatabaseStorage extends Storage  {
	
			public static final int KEY_NONE = 0;
			public static final int KEY_PRIMARY = 1;
			public static final int KEY_SECONDARY = 2;
			public static final int KEY_FOREIGN = 3;
			public static final int KEY_NOTNULL = 4;
	
			public void init(MMBase mmb, XMLDatabaseReader reader);
	
			public boolean getStoreBinaryAsFile();
	
			public void setStoreBinaryAsFile(boolean value);
	
			public File getBinaryFilePath();

			public void setBinaryFilePath(File path);
	
			public void setFieldNameMap(Map fieldmap);
	
			public Map getFieldNameMap();
	
			public void setTypeMap(Map typeMap);
	
			public Map getTypeMap();
	
			public void setPrimaryKeyScheme(String scheme);
	
			public String getPrimaryKeyScheme();
	
			public void setNotNullScheme(String scheme);
	
			public String getNotNullScheme();
	
			public void setKeyScheme(String scheme);
	
			public String getKeyScheme();
	
			public void setForeignKeyScheme(String scheme);
	
			public String getForeignKeyScheme();
	
			public void setCreateScheme(String scheme);
	
			public String getCreateScheme();
	
			public void setCreateExtendedScheme(String scheme);
	
			public String getCreateExtendedScheme();
	
			public void setMaxDropSize(int value);
	
			public int getMaxDropSize();
	
			public boolean supportsExtendedTables();
	
			public String mapToTableFieldName(String fieldName);
	
			public String mapToMMBaseFieldName(String fieldName);
	
			public JDBCInterface getJDBC();
	
			public void loadFieldFromTable(MMObjectNode node, String fieldName, ResultSet rs,int i);
	
			public boolean setValuePreparedStatement( PreparedStatement stmt, MMObjectNode node, String key, int i)
					throws SQLException;
	
			public void registerChanged(MMObjectNode node, String change);
	
	}
	]]></programlisting>
			<formalpara>
				<title>DatabaseStorage Methods:</title>
				<para><variablelist>
						<varlistentry>
							<term>Constants: KEY_NONE, KEY_PRIMARY, KEY_SECONDARY, KEY_FOREIGN, KEY_NOTNULL</term>
							<listitem>
								<para>Constants used to indicate whether a certain field is a key, and if so, what type.
								It is used in the <methodname>constructFieldDefiniton()</methodname> method, which is defined in AbstractDatabaseStorage.
								</para>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>void init(MMBase mmb, XMLDatabaseReader reader);</methodname></term>
							<listitem>
								<para>Initializes the database layer. This reads database specific content from the database configuration document. If needed, the code creates a 'numbertable' for mmbase to track number generation. It should also load the JDBC mopdule, load database properties (such as whether it supports rollback, etc.)</para>
								<note><para>Rewriting XMLDatabaseReader to use sax, and act as a property holder, allows all configuration to be stored in a seperate class. That class can then also load schemes.</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>boolean getStoreBinaryAsFile();</methodname></term>
							<listitem>
								<para>Returns true if binaries are stored as files on disk, instead of in the database. Initially retrieved form the databse configuration file (if the bolbdatapath is given, this method returns true)</para>
								<note><para>Should be renamed, moved to a seperate class (XMLDatabaseReader?)</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>void setStoreBinaryAsFile(boolean value);</methodname></term>
							<listitem>
								<para>Sets whether binaries should be stored as files on disk, instead of in the database.</para>
								<note><para>Should be renamed, moved to a seperate class (XMLDatabaseReader?)</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>File getBinaryFilePath();</methodname></term>
							<listitem>
								<para>Returns the directory where binary fiels are to be stored (provided getStoreBinaryAsFile() returns true).</para>
								<note><para>Should be moved to a seperate class (XMLDatabaseReader?)</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>void setBinaryFilePath(File path);</methodname></term>
							<listitem>
								<para>Sets the directory where binary files are to be stored. The initial value is <filename class="directory">/tmp/data</filename>.</para>
								<note><para>Should be moved to a seperate class (XMLDatabaseReader?)</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>void setFieldNameMap(Map fieldmap);</methodname></term>
							<listitem>
								<para>Sets the mapping of MMBase fieldnames (typically reserved words) to database fieldnames. Loaded form the database configuration file.</para>
								<para>This map is used to map MMBase fieldnames to fieldnames that are acceptable to the database, i.e. Oracle does not accept 'number' as a fieldname, though MMBase uses it as a field name.</para>
								<note><para>Remove (not really needed) or move to a seperate class (XMLDatabaseReader?).</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>Map getFieldNameMap();</methodname></term>
							<listitem>
								<para>Returns the mapping of MMBase fieldnames.</para>
								<note><para>Remove (not really needed) or move to a seperate class (XMLDatabaseReader?)</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>void setTypeMap(Map typeMap);</methodname></term>
							<listitem>
								<para>Sets the type map used to convert MMBase types to database types (needed for creating tables).</para>
								<note><para>Remove (not really needed) or move to a seperate class (XMLDatabaseReader?)</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>Map getTypeMap();</methodname></term>
							<listitem>
								<para>Returns the type map.</para>
								<note><para>Remove (not really needed) or move to a seperate class (XMLDatabaseReader?)</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>void setPrimaryKeyScheme(String scheme);</methodname></term>
							<listitem>
								<para>The primary key scheme is a parameterized string that defines the definition part of a primary key field.</para>
								<variablelist>
								  <title>Parameters</title>
									<varlistentry>
									  <term>{0}</term>
										<listitem><para>the name of the field to create.</para></listitem>
									</varlistentry>
									<varlistentry>
									  <term>{1}</term>
										<listitem><para>the field type definition (i.e. 'varchar(64)' )</para></listitem>
									</varlistentry>
								</variablelist>
								<note><para>Should be moved to a separate utility class (Schemes)</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>String getPrimaryKeyScheme();</methodname></term>
							<listitem>
								<para>The primary key scheme is a parameterized string that defines the definition part of a primary key field.</para>
								<note><para>Should be moved to a separate utility class (Schemes)</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>void setNotNullScheme(String scheme);</methodname></term>
							<listitem>
								<para>The not null scheme is a parameterized string that defines the definition part of a field that cannot be null.</para>
								<variablelist>
								  <title>Parameters</title>
									<varlistentry>
									  <term>{0}</term>
										<listitem><para>the name of the field to create.</para></listitem>
									</varlistentry>
									<varlistentry>
									  <term>{1}</term>
										<listitem><para>the field type definition (i.e. 'varchar(64)' )</para></listitem>
									</varlistentry>
								</variablelist>
								<note><para>Should be moved to a separate utility class (Schemes)</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>String getNotNullScheme();</methodname></term>
							<listitem>
								<para>The not null scheme is a parameterized string that defines the definition part of a field that cannot be null.</para>
								<note><para>Should be moved to a separate utility class (Schemes)</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>void setKeyScheme(String scheme);</methodname></term>
							<listitem>
								<para>The key scheme is a parameterized string that defines the definition part of a field that is a secondary (unique) key.</para>
								<variablelist>
								  <title>Parameters</title>
									<varlistentry>
									  <term>{0}</term>
										<listitem><para>the name of the field to create.</para></listitem>
									</varlistentry>
									<varlistentry>
									  <term>{1}</term>
										<listitem><para>the field type definition (i.e. 'varchar(64)' )</para></listitem>
									</varlistentry>
								</variablelist>
								<note><para>Should be moved to a separate utility class (Schemes)</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>String getKeyScheme();</methodname></term>
							<listitem>
								<para>The key scheme is a parameterized string that defines the definition part of a field that is a secondary (unique) key.</para>
								<note><para>Should be moved to a separate utility class (Schemes)</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>void setForeignKeyScheme(String scheme);</methodname></term>
							<listitem>
								<para>The foreign key scheme is a parameterized string that defines the definition part of a field that is a foreign key.</para>
								<variablelist>
								  <title>Parameters</title>
									<varlistentry>
									  <term>{0}</term>
										<listitem><para>the name of the field to create.</para></listitem>
									</varlistentry>
									<varlistentry>
									  <term>{1}</term>
										<listitem><para>the field type definition (i.e. 'varchar(64)' )</para></listitem>
									</varlistentry>
								</variablelist>
								<note><para>Should be moved to a separate utility class (Schemes)</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>String getForeignKeyScheme();</methodname></term>
							<listitem>
								<para>The foreign key scheme is a parameterized string that defines the definition part of a field that is a foreign key.</para>
								<note><para>Should be moved to a separate utility class (Schemes)</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>void setCreateScheme(String scheme);</methodname></term>
							<listitem>
								<para>The create scheme is a parameterized string that describes the SQL create table statement.</para>
								<variablelist>
								  <title>Parameters</title>
									<varlistentry>
									  <term>{0}</term>
										<listitem><para>the name of the table to create.</para></listitem>
									</varlistentry>
									<varlistentry>
									  <term>{1}</term>
										<listitem><para>the list of field definitions (seperated by commas)</para></listitem>
									</varlistentry>
								</variablelist>
								<note><para>Should be moved to a separate utility class (Schemes).  Scheme may need to be extended with additional information, such as keys to use.</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>String getCreateScheme();</methodname></term>
							<listitem>
								<para>The create scheme is a parameterized string that describes the SQL create table statement.</para>
								<note><para>Should be moved to a separate utility class (Schemes)</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>void setCreateExtendedScheme(String scheme);</methodname></term>
							<listitem>
								<para>The create scheme is a parameterized string that describes the SQL create table statement for extended (OO) tables.</para>
								<variablelist>
								  <title>Parameters</title>
									<varlistentry>
									  <term>{0}</term>
										<listitem><para>the name of the table to create.</para></listitem>
									</varlistentry>
									<varlistentry>
									  <term>{1}</term>
										<listitem><para>the list of field definitions (seperated by commas)</para></listitem>
									</varlistentry>
									<varlistentry>
									  <term>{2}</term>
										<listitem><para>the name of teh table to extend</para></listitem>
									</varlistentry>
								</variablelist>
								<note><para>Should be moved to a separate utility class (Schemes). Scheme may need to be extended with additional information, such as keys to use.</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>String getCreateExtendedScheme();</methodname></term>
							<listitem>
								<para>The create scheme is a parameterized string that describes the SQL create table statement for extended (OO) tables. Only for OO databases.</para>
								<note><para>Should be moved to a separate utility class (Schemes)</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>void setMaxDropSize(int value);</methodname></term>
							<listitem>
								<para>Sets the maximum size of a table before it can be 'dropped', generally as part of some table altering process.</para>
								<note><para>Silly (mostly undocumented) property which should be dropped. Maybe replace with a field indicating whether tables can be altered.</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>int getMaxDropSize();</methodname></term>
							<listitem>
								<para>Returns the maximum size of a table before it can be 'dropped', generally as part of some table altering process.</para>
								<note><para>Should be dropped.</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>boolean supportsExtendedTables();</methodname></term>
							<listitem>
								<para>Returns true of the database used is OO.</para>
								<note><para>Remove this property - methods depending on thsi property (i.e. create table method) should be overridden in the approppriate classes.</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>String mapToTableFieldName(String fieldName);</methodname></term>
							<listitem>
								<para>Maps a mmbase fieldname to a database fieldname. Only used internally.</para>
								<note><para>If interfaces are changed to abstract classes, this method should become protected.</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>String mapToMMBaseFieldName(String fieldName);</methodname></term>
							<listitem>
								<para>Maps a database fieldname to a mmbase fieldname. Only used internally.</para>
								<note><para>If interfaces are changed to abstract classes, this method should become protected.</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>JDBCInterface getJDBC();</methodname></term>
							<listitem>
								<para>Returns the JDBC Module.</para>
								<note><para>The JDBC module should be moved and renamed (org.mmbase.storage.database.JDBC).</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>void loadFieldFromTable(MMObjectNode node, String fieldName, ResultSet rs,int i);</methodname></term>
							<listitem>
								<para>Stores a field from a table ResultSet in a MMObjectNode (using the index in the resultset and the fieldname of the node). This method is called by DatabaseTransaction.</para>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>boolean setValuePreparedStatement( PreparedStatement stmt, MMObjectNode node, String key, int i) throws SQLException;</methodname></term>
							<listitem>
								<para>Stores a field from a Node in a prepatred statement (using the index in the statement and the fieldname of the node). This method is called by DatabaseTransaction.</para>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>void registerChanged(MMObjectNode node, String change);</methodname></term>
							<listitem>
								<para>Register a change of a Node in the database.</para>
								<note><para>Move to Transaction</para></note>
							</listitem>
						</varlistentry>
					</variablelist></para>
			</formalpara>
		</section>
	</section>

	<section id="classes">
    <title>Classes</title>
		<para>TODO: explain classes</para>

		<section id="DatabaseTransaction">
			<title>DatabaseTransaction Interface</title>
			<para>DatabaseTransaction is an implementation of Transaction for use with databases using JDBC.</para>
			<programlisting format="linespecific"><![CDATA[
public class DatabaseTransaction {

    public DatabaseTransaction(DatabaseStorage database, boolean useRollback) throws StorageException;

    public boolean databaseSupportsRollback() throws StorageException;

    public boolean hasTable(String tableName) throws StorageException;

    public Set getTables(String baseName) throws StorageException;

    public void registerChanged(MMObjectNode node, String change);

    public ResultSet executeQuery(String sql) throws StorageException;

    public boolean executeUpdate(String sql) throws StorageException;

    public boolean executeUpdate(String sql, List fields, MMObjectNode node) throws StorageException;

    public int getIntegerResult();

    public MMObjectNode getNodeResult(MMObjectBuilder builder);

}]]></programlisting>
			<formalpara>
				<title>DatabaseTransaction Methods (in addition to the methods in Transaction):</title>
				<para><variablelist>
						<varlistentry>
							<term><methodname>DatabaseTransaction(DatabaseStorage database, boolean useRollback) throws StorageException;</methodname></term>
							<listitem>
								<para>The constructor for the DatabaseTransaction object.</para>
								<para>The transaction attempts to obtain a connection with the database, using the DatabaseStorage to obtain the needed data (such as a reference to the JDBC module).
								The parameter supplied indicates whether rollback should be enabled (if available). You can explicitly turn off rollback facilities (which might slow down database access) for internal routines by specifying useRollback as false.</para>
								<note><para>If <parameter class="option">userollback</parameter> is true, this method calls the DatabaseStorage <methodname>supportsRollback()</methodname> method to check if rollback is possible. The DatabaseStorage will generally have pre-determined whether rollback is possible or not (when initializing the storage layer) by calling the <methodname>databaseSupportsRollback()</methodname> method.</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>boolean databaseSupportsRollback() throws StorageException;</methodname></term>
							<listitem>
								<para>Queries the database metadata to test whether this database supports rollback. Rollback of a transaction is defined as making undone any changes to the persistent storage used (i.e. a database), since the transaction started. Not all databases support this.</para>
								<note><para>This method should be called only once, at the initialization of the storage layer, to determine whether rollback is available. It may be worthwhile to replace this method with a getMetaData() method. We can then move the rollback test itself to the DatabaseStorage.</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>boolean hasTable(String tableName) throws StorageException;</methodname></term>
							<listitem>
								<para>Queries the database metadata to test whether a given table exists.</para>
								<note><para>It may be worthwhile to replace this method with a getMetaData() method (see <methodname>databaseSupportsRollback()</methodname>. We can then move the table test itself to the DatabaseStorage.</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>Set getTables(String baseName) throws StorageException;</methodname></term>
							<listitem>
								<para>Queries the database metadata to obtain a list of tables following a specified pattern.</para>
								<note><para>It may be worthwhile to replace this method with a getMetaData() method (see <methodname>databaseSupportsRollback()</methodname>. We can then move the table list itself to the DatabaseStorage.</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>void registerChanged(MMObjectNode node, String change);</methodname></term>
							<listitem>
								<para>Register changes for broadcasting after commit.</para>
								<para>The Transaction maintains a cache of changes to nodes. If the Transaction is successfully committed, it will broadcast these changes using MultiCast, by calling the <methodname>registerChanged</methodname> in the DatabaseStorage. This ensures that changes are only broadcasted if the commit was successful.</para>
								<note><para>Current code does not take into account Transactions that do not rollback. If no rollback support is present, the changes should immediately be broadcasted, instead of cached.</para></note>
								<note><para>The <methodname>commit()</methodname> method calls the <methodname>registerChanged()</methodname> in DatabaseStorage to actually broadcast the events. It is more appropriate to move that code from DatabaseStorage to DatabaseTransaction. (In fact, it would make sense to add the method to the Transaction interface, as it is not specifically database related and generally required to maintain a correct state between servers)</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>ResultSet executeQuery(String sql) throws StorageException;</methodname></term>
							<listitem>
								<para>Execute a SQL statement on the database, and return the ResultSet.</para>
								<note><para>I generally feel that the Query interface should be used by DatabaseStorage. DatabaseTransaction merely passes commands (sql statements) to the database. I think it is appropriate to pass sql strings, rather than query objects, especially as it allows for the DatabaseStorage to pass it's own statements.</para></note>
								<note><para>The reason we do not pass a Statement object is that this allows ONE entry point where connections and statements are created. This allows for the Transaction to use connection pools and logging separate from the Database storage.</para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>boolean executeUpdate(String sql) throws StorageException;</methodname></term>
							<listitem>
								<para>Execute a SQL statement on the database. The statement should be an 'update' sql query (one that does not return a resultset). If the execution was successful (but did not generate an error) the method returns true.</para>
								<note><para>see <methodname>executeQuery()</methodname></para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>boolean executeUpdate(String sql, List fields, MMObjectNode node) throws StorageException;</methodname></term>
							<listitem>
							  <para>Execute a SQL statement on the database. The statement should be an 'update' sql query (one that does not return a resultset). The sql query will be run using a prepared statement, which is then filled with content from the passed node. The fields parameter contains the fields to add to the statement. The SQL statement should be appropriate to be used as a prepared statement, and have the appropriate type and number of parameters (as in fields).</para>
								<para>If the execution was successful (but did not generate an error) the method returns true.</para>
								<note><para>see <methodname>executeQuery()</methodname></para></note>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>int getIntegerResult();</methodname></term>
							<listitem>
								<para>Attempts to return a single integer result from the last retrieved resultset. Use this method to return the result of a query which returns a resultset of records containing one single numeric field If the query failed, or returned an unexpected result, or if the resultset is exhausted, the function returns -1. If this is due to an error then the error is logged.</para>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><methodname>MMObjectNode getNodeResult(MMObjectBuilder builder);</methodname></term>
							<listitem>
								<para>Attempts to return a single Node from the last retrieved resultset. Use this method to return the result of a query which returns a resultset of records containing fields from a builder table. If the query failed, or returned an unexpected result, or if the resultset is exhausted, the function returns null. If this is due to an error then the error is logged. Currently does not work for clusternodes, as far as I know.</para>
								<note><para>This method (and <methodname>getIntegerResult()</methodname>) assume that Transaction can (and should) be used to temporarily store a resultset. If we choose for this approach (rather than move the code to DatabaseStorage), we would also need <methodname>getResultSet()</methodname> and <methodname>next()</methodname> methods, so we can iterate.</para></note>
							</listitem>
						</varlistentry>
					</variablelist></para>
			</formalpara>
		</section>

		<section id="AbstractDatabaseStorage">
			<title>AbstractDatabaseStorage Class</title>
			<para>TODO: explain class</para>
		</section>
	
		<section id="SQL92DatabaseStorage">
			<title>SQL92DatabaseStorage Class</title>
			<para>TODO: explain class</para>
		</section>
	
		<section id="OODatabaseStorage">
			<title>OODatabaseStorage Class</title>
			<para>TODO: explain class</para>
		</section>
	
		<section id="RelationalDatabaseStorage">
			<title>RelationalDatabaseStorage Class</title>
			<para>TODO: explain class</para>
		</section>
		
		<section id="Support2Storage">
			<title>Support2Storage Class</title>
			<para>TODO: explain class</para>
		</section>
	</section>
		
	<section id="exceptions">
    <title>Exceptions</title>
		<para>TODO: explain exceptions</para>

		<section id="StorageException">
			<title>StorageException</title>
			<para>TODO: explain exception</para>
		</section>
		
		<section id="UnsupportedDatabaseOperationException">
			<title>UnsupportedDatabaseOperationException</title>
			<para>TODO: explain exception</para>
		</section>
	</section>

</article>
