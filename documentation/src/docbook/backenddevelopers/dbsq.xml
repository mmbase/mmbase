<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd">
<article>
  <articleinfo>
    <title>SearchQuery introduction</title>

    <date>2002-12-05</date>

    <edition>$Id$</edition>

    <authorgroup>
      <author>
        <firstname>Rob</firstname>

        <surname>van Maris</surname>

        <affiliation>
          <orgname>Finalist IT Group</orgname>
        </affiliation>
      </author>
    </authorgroup>

    <legalnotice>
      <para>This software is OSI Certified Open Source Software. OSI Certified
      is a certification mark of the Open Source Initiative.</para>

      <para>The license (Mozilla version 1.0) can be read at the MMBase site.
      See <ulink url="http://www.mmbase.org/license">http://www.mmbase.org/license</ulink></para>
    </legalnotice>
  </articleinfo>

  <section>
    <title>Background</title>

    <para>The database search queries project was started to address the
    following needs:</para>

    <itemizedlist>
      <listitem>
        <para>deliver search queries inside MMBase in a uniform and
        device-independent manner</para>
      </listitem>

      <listitem>
        <para>provide mechanisms to process these queries in a device-specific
        way that ensures optimal performance</para>
      </listitem>
    </itemizedlist>

    <para>The plan of action for the project defined these three stages, that
    have now been completed:</para>

    <orderedlist>
      <listitem>
        <para>Introduction a <classname>SearchQuery</classname> object,
        capable of representing all kind of search queries supported by
        standard relational databases.</para>
      </listitem>

      <listitem>
        <para>Introduction of an extension mechanism to enable use of
        additional, vendor specific, database functionality.</para>
      </listitem>

      <listitem>
        <para>Integration of the <classname>SearchQuery</classname> into
        existing MMBase code.</para>
      </listitem>
    </orderedlist>

    <para>This article introduces design and implementation of the resulting
    <classname>SearchQuery</classname> API&#39;s.</para>

    <para>If you&#39;re looking for the shortest path to code-level
    understanding, try skipping the next sections for the moment, and jump
    straight to the &#34;<link linkend="query_codesamples">code samples</link>&#34;
    sections right away. </para>

    <para>Either way, once you understand the relevant code samples, the
    javadoc documentation provides the API details you&#39;ll need to go from
    there.</para>
  </section>

  <section>
    <title>Resources</title>

    <itemizedlist>
      <listitem>
        <para>Sourcecode of JUnit tests is available from \dbsq\test\src in
        CVS module speeltuin.</para>
      </listitem>

      <listitem>
        <para>Sourcecode of the code samples is available from \dbsq\src in
        CVS module speeltuin.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Package descriptions</title>

    <section>
      <title><classname>org.mmbase.storage.search</classname></title>

      <para>Interfaces for query objects, query handlers and dependent
      objects. </para>

      <para>Query objects represent search requests, query handlers process
      requests represented by query objects. (More on this further on.)</para>

      <para>The query interfaces specify the interfaces exposed by query
      objects, in order for query handlers to retrieve the query data. This
      will enable query handlers to be implemented independent from query
      implementations.</para>

      <para>Note that these interfaces do not specify how query objects are
      constructed, see next section.</para>
    </section>

    <section>
      <title><classname>org.mmbase.storage.search.implementation</classname></title>

      <para>Classes implementing the query interfaces described in the
      previous section. These also provide methods to construct queries.</para>
    </section>

    <section>
      <title><classname>org.mmbase.storage.search.implementation.database</classname></title>

      <para>Implementation classes that rely on a database providing the
      storage. This includes the basic query handler implementation.</para>

      <para>The basic query handler delegates generation of SQL statements to
      a dedicated handler, the SQL handler.</para>
    </section>
  </section>

  <section>
    <title>Query objects</title>

    <section>
      <title>Interfaces</title>

      <para>Search queries are defined by these interfaces:</para>

      <itemizedlist>
        <listitem>
          <para><classname>SearchQuery</classname>: the query</para>
        </listitem>

        <listitem>
          <para><classname>Step</classname>: a query step, generalizes the
          notion of a table</para>
        </listitem>

        <listitem>
          <para><classname>StepField</classname>: a step field, generalizes
          the notion of a field from a table</para>
        </listitem>

        <listitem>
          <para><classname>RelationStep</classname>: a <classname>Step</classname>
          defining a relation between two steps.</para>
        </listitem>

        <listitem>
          <para><classname>SortOrder</classname>: a sorting order</para>
        </listitem>

        <listitem>
          <para><classname>Constraint</classname>: a constraint</para>
        </listitem>

        <listitem>
          <para><classname>CompositeConstraint</classname>: a number of
          constraints, combined using AND or OR.</para>
        </listitem>

        <listitem>
          <para><classname>Constraint</classname> subinterfaces for specific
          constraint types.</para>
        </listitem>
      </itemizedlist>

      <para>In all cases, the interface provides:</para>

      <orderedlist>
        <listitem>
          <para>Accessor methods, to retrieve the query data.</para>
        </listitem>

        <listitem>
          <para><methodname>equals()</methodname> and
          <methodname>hashCode()</methodname> methods, enabling queries and
          parts of queries to be compared to each other. This is anticipates
          future developments, like caching of queries.</para>
        </listitem>

        <listitem>
          <para>A <methodname>toString()</methodname> method, provided for
          debugging purposes.</para>
        </listitem>
      </orderedlist>
    </section>

    <section>
      <title>Implementation</title>

      <para>The implementation classes provide methods to construct query
      objects. See next section for examples.</para>

      <para>It may seem that the interfaces have been provided in anticipation
      of a number of different implementations. This is in fact not the case,
      as I can&#39;t think of a reason why one (basic) implementation should
      not suffice. On the other hand, a number of different query handlers
      seems likely. The interfaces are provided as a stable and clearcut
      specification of the interaction between query and query handler,
      allowing future enhancements to the query implementation to evolve,
      without breaking the query handler implementation.</para>
    </section>

    <section>
      <title id="query_codesamples">Code samples</title>

      <para>These code samples concentrate on how query objects represent
      search query requests analogous to SQL92 SELECT statements. To see how
      to retrieve actual nodes using query objects, refer to the <link
      linkend="query_handlers_codesamples">code samples</link> in the &#34;<link
      linkend="query_handlers">Query handlers</link>&#34; sections.</para>

      <para>In these examples, the represented queries are shown in SQL92
      form, ignoring vendor specific issues like reserved words and deviating
      syntax. (Actual query handlers will take these into account as well.)</para>

      <para>An example of creating a simple query with one step and one field:</para>

      <programlisting>        MMBase mmbase = MMBase.getMMBase();
        MMObjectBuilder images = mmbase.getBuilder(&#34;images&#34;);
        InsRel insrel = mmbase.getInsRel();
        MMObjectBuilder pools = mmbase.getBuilder(&#34;pools&#34;);

        // Create query.
        BasicSearchQuery query = new BasicSearchQuery();
        BasicStep step1 = query.addStep(images);
        FieldDefs imagesTitle = images.getField(&#34;title&#34;);
        BasicStepField field1 = query.addField(step1, imagesTitle);
</programlisting>

      <screen> Result:
        SELECT title FROM &#60;basename&#62;_images images
</screen>

      <para>Add a related step.</para>

      <programlisting>        InsRel insrel = mmbase.getInsRel();
        MMObjectBuilder pools = mmbase.getBuilder(&#34;pools&#34;);
        BasicRelationStep step2 = query.addRelationStep(insrel, pools);
        step2.setDirectionality(RelationStep.DIRECTIONS_DESTINATION);
</programlisting>

      <screen> Result:
        SELECT images.title
        FROM &#60;basename&#62;_images images,
            &#60;basename&#62;_insrel insrel,
            &#60;basename&#62;_pools pools
        WHERE (images.number=insrel.snumber
        AND pools.number=insrel.dnumber)
</screen>

      <para>Add another field.</para>

      <programlisting>        BasicStep step3 = (BasicStep) step2.getNext();
        FieldDefs poolsName = pools.getField(&#34;name&#34;);
        BasicStepField field2 = query.addField(step3, poolsName);
</programlisting>

      <screen> Result:
        SELECT images.title,
            pools.name
        FROM &#60;basename&#62;_images images,
            &#60;basename&#62;_insrel insrel,
            &#60;basename&#62;_pools pools
        WHERE (images.number=insrel.snumber
        AND pools.number=insrel.dnumber)
</screen>

      <para>Add nodenumber constraint.</para>

      <programlisting>        step3.addNode(100);
</programlisting>

      <screen> Result:
        SELECT images.title,
            pools.name
        FROM &#60;basename&#62;_images images,
            &#60;basename&#62;_insrel insrel,
            &#60;basename&#62;_pools pools
        WHERE pools.number IN (100)
        AND (images.number=insrel.snumber
        AND pools.number=insrel.dnumber)</screen>

      <para>Add field value constraint.</para>

      <programlisting>        BasicFieldValueConstraint constraint
            = new BasicFieldValueConstraint(field1, &#34;Logo&#34;);
        query.setConstraint(constraint);
</programlisting>

      <screen> Result:
        SELECT images.title,
            pools.name
        FROM &#60;basename&#62;_images images,
            &#60;basename&#62;_insrel insrel,
            &#60;basename&#62;_pools pools
        WHERE pools.number IN (100)
        AND (images.number=insrel.snumber
        AND pools.number=insrel.dnumber)
        AND images.title=&#39;Logo&#39;
</screen>

      <para>Add sort order.</para>

      <programlisting>        BasicSortOrder sortOrder = query.addSortOrder(field1);
</programlisting>

      <screen> Result:
        SELECT images.title,
            pools.name
        FROM &#60;basename&#62;_images images,
            &#60;basename&#62;_insrel insrel,
            &#60;basename&#62;_pools pools
        WHERE pools.number IN (100)
        AND (images.number=insrel.snumber
        AND pools.number=insrel.dnumber)
        AND images.title=&#39;Logo&#39;
        ORDER BY title ASC
</screen>

      <para>An example of creating an aggregating query counting a single
      field:</para>

      <programlisting>        query = new BasicSearchQuery(true);
        step1 = query.addStep(images);
        FieldDefs imagesNumber = images.getField(&#34;number&#34;);
        BasicAggregatedField field1a = query.addAggregatedField(
            step1, imagesNumber, AggregatedField.AGGREGATION_TYPE_COUNT);
        field1a.setAlias(&#34;number_count&#34;);
</programlisting>

      <screen> Result:
        SELECT COUNT(number) AS number_count
        FROM &#60;basename&#62;_images images
</screen>

      <para>Add grouping on a second field.</para>

      <programlisting>        BasicAggregatedField field2a = query.addAggregatedField(
            step1, imagesTitle, AggregatedField.AGGREGATION_TYPE_GROUP_BY);
</programlisting>

      <screen> Result:
        SELECT COUNT(number) AS number_count,
            title
        FROM &#60;basename&#62;_images images
        GROUP BY title
</screen>

      <para>The complete <link linkend="query_codelisting">listing</link> of
      the sample program can be found at the end of this article.</para>
    </section>
  </section>

  <section>
    <title id="query_handlers">Query handlers</title>

    <section>
      <title>SearchQueryHandler interface</title>

      <para>Now that we can create query objects, we need a way to deliver
      these to the database layer.</para>

      <para>For this purpose, the databaselayer should provide an object
      implementing the <classname>SearchQueryHandler</classname> interface,
      that can process queries.</para>

      <programlisting>package org.mmbase.storage.search;

public interface SearchQueryHandler {

    public List getNodes(SearchQuery query, MMObjectBuilder builder)
    throws SearchQueryException;
</programlisting>

      <para>Method <methodname>getNodes()</methodname> executes the search,
      and returns the result as a list of nodes of the type corresponding to
      the specified builder. I.e. either real nodes (<classname>MMObjectNode</classname>
      instances), clusternodes (<classname>ClusterNode</classname> instances)
      or resultnodes (<classname>ResultNode</classname> instances). More on
      this in the next section.</para>

      <para>In addition, a method is provided to test if the underlying
      storage supports a certain type of constraint:</para>

      <programlisting>    public int getSupportLevel(Constraint constraint, SearchQuery query)
    throws SearchQueryException;
</programlisting>

      <para>Four levels of support are defined:</para>

      <programlisting>    public final static int SUPPORT_NONE = 0;
    public final static int SUPPORT_WEAK = 1;
    public final static int SUPPORT_NORMAL = 2;
    public final static int SUPPORT_OPTIMAL = 3;
</programlisting>

      <para>A similar method is provided to test support for other features of
      a search query:</para>

      <programlisting>    public int getSupportLevel(int feature, SearchQuery query)
    throws SearchQueryException;
</programlisting>

      <para>This method takes as argument one of these constraints:</para>

      <programlisting>    public final static int FEATURE_MAX_NUMBER = 1;
    public final static int FEATURE_OFFSET = 2;
</programlisting>
    </section>

    <section>
      <title>Retrieving search results</title>

      <para>Depending on the second argument that is provided (builder), the
      handler&#39;s method <methodname>getNodes(query,builder)</methodname>
      will return a list of nodes of one of the following types:</para>

      <itemizedlist>
        <listitem>
          <para><classname>MMObjectNode</classname> - when a
          <classname>MMObjectBuilder</classname> is specified, or a subclass
          that is not a <classname>VirtualBuilder</classname>.</para>

          <para>For this to work as expected, the query is required to include
          all persistent fields of the nodetype that is retrieved.</para>

          <para>Generally, this functionality is not meant to be accessed
          directly, but instead through the MMObjectBuilder method
          <methodname>getNodes(query)</methodname>, which takes care of things
          like nodecache and inheritance issues as well.</para>
        </listitem>

        <listitem>
          <para><classname>ClusterNode</classname> - when a
          <classname>ClusterBuilder</classname> is specified.</para>

          <para>For this to work properly, the aliases of the steps in the
          query should follow the conventions for tablenames in multilevel
          queries. (TODO: elaborate)</para>

          <para>Generally, this functionality is not meant to be accessed
          directly, but instead through the ClusterBuilder method
          <methodname>getClusterNodes(query)</methodname>.</para>
        </listitem>

        <listitem>
          <para><classname>ResultNode</classname> - when a
          <classname>ResultBuilder</classname> is specified.</para>

          <para>Resultnodes are able to represent the results of arbitrary
          search queries without the restrictions of real or clusternodes. In
          particular: field aliases can be used to rename the fields in the
          result, results can be grouped/aggregated, and aggregate functions
          like <command><methodname>COUNT</methodname></command>,
          <methodname>MIN</methodname> and <methodname>MAX</methodname> can be
          used.</para>

          <para>Generally, this functionality can be accessed directly, and is
          meant to provide an alternative to directly executing search queries
          on the database.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>BasicQueryHandler</title>

      <para>A basic implementation of the <classname>SearchQueryHandler</classname>
      interface is provided by <classname>BasicQueryHandler,</classname> that
      can be used when the storage is provided by a SQL 92 compliant database.</para>

      <para>A <classname>BasicQueryHandler</classname> instance uses an
      <classname>SqlHandler</classname> object to create an SQL statement,
      executes the resulting query and converts the queryresults back to
      nodes.</para>

      <para>The <classname>SqlHandler</classname> interface isolates the
      functionality concerned with translating query objects to actual,
      possibly vendor-specific, SQL statements. The actual implementation
      class used will depend on the underlying database, and can be extended
      with additional functionality using additional handlers. See the API
      javadoc for more info.</para>
    </section>

    <section>
      <title id="query_handlers_codesamples">Code samples</title>

      <example>
        <title>Retrieving real nodes</title>

        <para>As a demonstration of retrieving real nodes, this example lists
        all nodes of type &#34;pools&#34;.</para>

        <programlisting>        MMBase mmbase = MMBase.getMMBase();
        MMObjectBuilder pools = mmbase.getBuilder(&#34;pools&#34;);
        MMObjectBuilder images = mmbase.getBuilder(&#34;images&#34;);
        InsRel insrel = mmbase.getInsRel();

        // EXAMPLE 1: query retrieving real nodes (of type pools).
        NodeSearchQuery query1 = new NodeSearchQuery(pools);
</programlisting>

        <para>Note the use of <classname>NodeSearchQuery</classname> to
        produce a query that retrieves real nodes.</para>

        <para>This will creates a query equivalent to:</para>

        <screen>        SELECT * FROM &#60;basename&#62;_pools pools
</screen>

        <para>This code executes the query and prints the result - real nodes
        with these fields: number, otype, owner, name, description.</para>

        <programlisting>        // Execute, get result as real nodes.
        List nodes1 = pools.getNodes(query1);
        Iterator iNodes1 = nodes1.iterator();
        while (iNodes1.hasNext()) {
            MMObjectNode node = (MMObjectNode) iNodes1.next();
            System.out.println(&#34;Real node: &#34; + node);
        }</programlisting>
      </example>

      <example>
        <title>Retrieving clusternodes</title>

        <para>As a demonstration of retrieving clusternodes, this example
        lists number fields of related pools and images, following relations
        from pools to images.</para>

        <programlisting>        // EXAMPLE 2: query retrieving clusternodes.
        BasicSearchQuery query2 = new BasicSearchQuery();
        BasicStep step2a = query2.addStep(pools);
        BasicRelationStep step2b = query2.addRelationStep(insrel, images);
        step2b.setDirectionality(RelationStep.DIRECTIONS_DESTINATION);
        Step step2c = step2b.getNext();
        // Add at least the number fields of all steps.
        query2.addField(step2a, pools.getField(&#34;number&#34;));
        query2.addField(step2b, insrel.getField(&#34;number&#34;));
        query2.addField(step2c, images.getField(&#34;number&#34;));
</programlisting>

        <para>This creates the following query:</para>

        <screen>        SELECT
            pools.number,
            insrel.number,
            images.number
        FROM
            &#60;basename&#62;_pools pools,
            &#60;basename&#62;_insrel insrel,
            &#60;basename&#62;_images images
        WHERE (pools.number = insrel.snumber
        AND images.number = insrel.dnumber)
</screen>

        <para>This code executes the query and prints the results -
        clusternodes with these fields: pools.number, insrel.number,
        images.number.</para>

        <programlisting>        // Execute, result as clusternodes.
        ClusterBuilder clusterBuilder = mmbase.getClusterBuilder();
        List nodes2 = clusterBuilder.getClusterNodes(query2);
        Iterator iNodes2 = nodes2.iterator();
        while (iNodes2.hasNext()) {
            ClusterNode node = (ClusterNode) iNodes2.next();
            System.out.println(&#34;Clusternode: &#34; + node);
        }</programlisting>
      </example>

      <example>
        <title>Retrieving clusternodes using table aliases</title>

        <para>Alternatively we could use table aliases to use tablenames
        appended with a digit:</para>

        <programlisting>        // EXAMPLE 3: query retrieving clusternodes using table aliases.
        BasicSearchQuery query3 = new BasicSearchQuery();
        BasicStep step3a = query3.addStep(pools);
        BasicRelationStep step3b = query3.addRelationStep(insrel, images);
        step3b.setDirectionality(RelationStep.DIRECTIONS_DESTINATION);
        BasicStep step3c = (BasicStep) step3b.getNext();
        // Set table aliases.
        step3a.setAlias(&#34;pools0&#34;);
        step3c.setAlias(&#34;images3&#34;);
        // Add at least the number fields of all steps.
        query3.addField(step3a, pools.getField(&#34;number&#34;));
        query3.addField(step3b, insrel.getField(&#34;number&#34;));
        query3.addField(step3c, images.getField(&#34;number&#34;));</programlisting>

        <para>This creates the following query:<programlisting>        SELECT
            pools0.number,
            insrel.number,
            images3.number
        FROM
            &#60;basename&#62;_pools pools0,
            &#60;basename&#62;_insrel insrel,
            &#60;basename&#62;_images images3
        WHERE (pools0.number = insrel.snumber
        AND images3.number = insrel.dnumber)
</programlisting></para>

        <para>Execution results in clusternodes with these fields:
        pools0.number, insrel.number, images3.number.</para>

        <programlisting>        // Execute, result as clusternodes.
        List nodes3 = clusterBuilder.getClusterNodes(query3);
        Iterator iNodes3 = nodes3.iterator();
        while (iNodes3.hasNext()) {
            ClusterNode node = (ClusterNode) iNodes3.next();
            System.out.println(&#34;Clusternode: &#34; + node);
        }</programlisting>
      </example>

      <example>
        <title>Retrieving resultnodes</title>

        <para>As a demonstration of retrieving resultnodes, this example lists
        arbitrary fields of nodes of type &#34;pools&#34;, using field
        aliases.</para>

        <programlisting>        // EXAMPLE 4: query retrieving resultnodes.
        BasicSearchQuery query4 = new BasicSearchQuery();
        BasicStep step4a = query4.addStep(pools);
        // Add some fields with field aliases.
        query4.addField(step4a, pools.getField(&#34;number&#34;)).setAlias(&#34;field1&#34;);
        query4.addField(step4a, pools.getField(&#34;name&#34;)).setAlias(&#34;field2&#34;);
        query4.addField(step4a, pools.getField(&#34;description&#34;)).setAlias(&#34;field3&#34;);
</programlisting>

        <para>This creates the following query:</para>

        <screen>        SELECT
            number AS field1,
            name AS field2,
            description AS field3
        FROM
            &#60;basename&#62;_pools pools
</screen>

        <para>This code executes the query and prints the results -
        resultnodes with these fields: field1, field2, field3</para>

        <programlisting>        // Execute, result as resultnodes.
        List nodes4 = handler.getNodes(query4, new ResultBuilder(mmbase, query4));
        Iterator iNodes4 = nodes4.iterator();
        while (iNodes4.hasNext()) {
            ResultNode node = (ResultNode) iNodes4.next();
            System.out.println(&#34;Resultnode: &#34; + node);
        }</programlisting>
      </example>

      <example>
        <title>Retrieving aggregated resultnodes</title>

        <para>Finally, to demonstrate aggregating queries, this example lists
        the results of applying aggregating functions COUNT, MIN and MAX on
        the &#34;number&#34; field of all nodes of type &#34;pools&#34;.</para>

        <programlisting>        // EXAMPLE 5: query retrieving aggregated resultnodes.
        BasicSearchQuery query5 = new BasicSearchQuery(true);
        BasicStep step5a = query5.addStep(pools);
        // Add some aggregated fields with field aliases.
        query5.addAggregatedField(step5a, pools.getField(&#34;number&#34;),
            AggregatedField.AGGREGATION_TYPE_COUNT).setAlias(&#34;count&#34;);
        query5.addAggregatedField(step5a, pools.getField(&#34;number&#34;),
            AggregatedField.AGGREGATION_TYPE_MIN).setAlias(&#34;min_number&#34;);
        query5.addAggregatedField(step5a, pools.getField(&#34;number&#34;),
            AggregatedField.AGGREGATION_TYPE_MAX).setAlias(&#34;max_number&#34;);</programlisting>

        <para>This creates the following query:</para>

        <screen>        SELECT
            COUNT(number) AS pool_count,
            MIN(number) AS min_number,
            MAX(number) AS max_number
        FROM
            &#60;basename&#62;_pools pools
</screen>

        <para>This code executes the query and prints the result - a
        resultnode with these fields: pool_count, min_number, max_number</para>

        <programlisting>        // Execute, result as resultnodes.
        List nodes5 = handler.getNodes(query5, new ResultBuilder(mmbase, query5));
        Iterator iNodes5 = nodes5.iterator();
        while (iNodes5.hasNext()) {
            ResultNode node = (ResultNode) iNodes5.next();
            System.out.println(&#34;Resultnode: &#34; + node);
        }</programlisting>
      </example>
    </section>
  </section>

  <section>
    <title>Sample program listings</title>

    <section>
      <title id="query_codelisting"><classname>QuerySampleCode</classname></title>

      <programlisting>/*

This software is OSI Certified Open Source Software.
OSI Certified is a certification mark of the Open Source Initiative.

The license (Mozilla version 1.0) can be read at the MMBase site.
See http://www.MMBase.org/license

*/
package org.mmbase.storage.search.sample;

import org.mmbase.module.core.*;
import org.mmbase.module.corebuilders.*;
import org.mmbase.storage.search.*;
import org.mmbase.storage.search.implementation.*;
import org.mmbase.storage.search.implementation.database.*;

/**
 * Sample code demonstrating basic usage of the &#60;code&#62;SearchQuery&#60;/code&#62;
 * interfaces.
 * &#60;p&#62;
 * Requires the following builders to be active: &#60;code&#62;builders&#60;/code&#62; and
 * &#60;code&#62;pools&#60;/code&#62;.
 *
 * @author  Rob van Maris
 * @version $Revision: 1.11 $
 * @since MMBase-1.7
 */
public class QuerySampleCode {

    /**
     * Demo application, writes resulting SQL strings to System.out.
     * &#60;br&#62;
     * Requires one commandline argument: the path to the MMBase config directory.
     * @param args Commandline arguments.
     */
    public static void main(String[] args) throws Exception {
        if (args.length &#60; 1) {
            System.out.println(
            &#34;Requires one commandline argument: the path to the MMBase config directory.&#34;);
            System.exit(1);
        }
        MMBaseContext.init(args[0], true);

        // Sql handler that generates SQL strings.
        SqlHandler sqlHandler = new BasicSqlHandler(new java.util.HashMap());

        MMBase mmbase = MMBase.getMMBase();
        MMObjectBuilder images = mmbase.getBuilder(&#34;images&#34;);

        // Create query.
        BasicSearchQuery query = new BasicSearchQuery();
        BasicStep step1 = query.addStep(images);
        FieldDefs imagesTitle = images.getField(&#34;title&#34;);
        BasicStepField field1 = query.addField(step1, imagesTitle);

/*
 Result:
        SELECT title FROM &#60;basename&#62;_images images
 */
        System.out.println(&#34;Result:\n&#34; + sqlHandler.toSql(query, sqlHandler));

        // Add a related step.
        InsRel insrel = mmbase.getInsRel();
        MMObjectBuilder pools = mmbase.getBuilder(&#34;pools&#34;);
        BasicRelationStep step2 = query.addRelationStep(insrel, pools);
        step2.setDirectionality(RelationStep.DIRECTIONS_DESTINATION);

/*
 Result:
        SELECT images.title
        FROM &#60;basename&#62;_images images,
            &#60;basename&#62;_insrel insrel,
            &#60;basename&#62;_pools pools
        WHERE (images.number=insrel.snumber
        AND pools.number=insrel.dnumber)
 */
        System.out.println(&#34;Result:\n&#34; + sqlHandler.toSql(query, sqlHandler));

        // Add another field.
        BasicStep step3 = (BasicStep) step2.getNext();
        FieldDefs poolsName = pools.getField(&#34;name&#34;);
        BasicStepField field2 = query.addField(step3, poolsName);

/*
 Result:
        SELECT images.title,
            pools.name
        FROM &#60;basename&#62;_images images,
            &#60;basename&#62;_insrel insrel,
            &#60;basename&#62;_pools pools
        WHERE (images.number=insrel.snumber
        AND pools.number=insrel.dnumber)
 */
        System.out.println(&#34;Result:\n&#34; + sqlHandler.toSql(query, sqlHandler));

        // Add nodenumber constraint.
        step3.addNode(100);

/*
 Result:
        SELECT images.title,
            pools.name
        FROM &#60;basename&#62;_images images,
            &#60;basename&#62;_insrel insrel,
            &#60;basename&#62;_pools pools
        WHERE pools.number IN (100)
        AND (images.number=insrel.snumber
        AND pools.number=insrel.dnumber)
 */
        System.out.println(&#34;Result:\n&#34; + sqlHandler.toSql(query, sqlHandler));

        // Add field value constraint.
        BasicFieldValueConstraint constraint
            = new BasicFieldValueConstraint(field1, &#34;Logo&#34;);
        query.setConstraint(constraint);

/*
 Result:
        SELECT images.title,
            pools.name
        FROM &#60;basename&#62;_images images,
            &#60;basename&#62;_insrel insrel,
            &#60;basename&#62;_pools pools
        WHERE pools.number IN (100)
        AND (images.number=insrel.snumber
        AND pools.number=insrel.dnumber)
        AND images.title=&#39;Logo&#39;
 */
        System.out.println(&#34;Result:\n&#34; + sqlHandler.toSql(query, sqlHandler));

        // Add sort order.
        BasicSortOrder sortOrder = query.addSortOrder(field1);

/*
 Result:
        SELECT images.title,
            pools.name
        FROM &#60;basename&#62;_images images,
            &#60;basename&#62;_insrel insrel,
            &#60;basename&#62;_pools pools
        WHERE pools.number IN (100)
        AND (images.number=insrel.snumber
        AND pools.number=insrel.dnumber)
        AND images.title=&#39;Logo&#39;
        ORDER BY title ASC
 */
        System.out.println(&#34;Result:\n&#34; + sqlHandler.toSql(query, sqlHandler));

        // An example of creating an aggregating query counting a single field:
        query = new BasicSearchQuery(true);
        step1 = query.addStep(images);
        FieldDefs imagesNumber = images.getField(&#34;number&#34;);
        BasicAggregatedField field1a = query.addAggregatedField(
            step1, imagesNumber, AggregatedField.AGGREGATION_TYPE_COUNT);
        field1a.setAlias(&#34;number_count&#34;);

/*
 Result:
        SELECT COUNT(number) AS number_count
        FROM &#60;basename&#62;_images images
 */
        System.out.println(&#34;Result:\n&#34; + sqlHandler.toSql(query, sqlHandler));

        // Add grouping on a second field.
        BasicAggregatedField field2a = query.addAggregatedField(
            step1, imagesTitle, AggregatedField.AGGREGATION_TYPE_GROUP_BY);

/*
 Result:
        SELECT COUNT(number) AS number_count,
            title
        FROM &#60;basename&#62;_images images
        GROUP BY title
 */
        System.out.println(&#34;Result:\n&#34; + sqlHandler.toSql(query, sqlHandler));

        System.exit(0);
    }

}
</programlisting>
    </section>

    <section>
      <title><classname>QueryHandlerSampleCode</classname></title>

      <programlisting>package org.mmbase.storage.search.sample;

import java.util.*;
import org.mmbase.module.core.*;
import org.mmbase.module.corebuilders.*;
import org.mmbase.storage.search.*;
import org.mmbase.storage.search.implementation.*;
import org.mmbase.storage.search.implementation.database.*;

/**
 * Sample code demonstrating basic usage of the
 * {@link org.mmbase.storage.search.SearchQueryHandler SearchQueryHandler}
 * interface.
 * &#60;p&#62;
 * Requires the following builders to be active: &#60;code&#62;builders&#60;/code&#62; and
 * &#60;code&#62;pools&#60;/code&#62;.
 *
 * @author  Rob van Maris
 * @version $Revision: 1.11 $
 * @since MMBase-1.7
 */
public class QueryHandlerSampleCode {

    /**
     * Demo application.
     * &#60;br&#62;
     * Requires one commandline argument: the path to the MMBase config directory.
     * @param args Commandline arguments.
     */
    public static void main(String args[]) throws Exception {
        if (args.length &#60; 1) {
            System.out.println(
            &#34;Requires one commandline argument: the path to the MMBase config directory.&#34;);
            System.exit(1);
        }
        MMBaseContext.init(args[0], true);
        MMBase mmbase = MMBase.getMMBase();

        // Sql handler that generates SQL strings.
        SqlHandler sqlHandler = new BasicSqlHandler(new java.util.HashMap());

        /* Several ways to get a queryhandler instance:
         1) Create a basic queryhandler, that supports (just) the
            ANSI SQL92 standard:
        SearchQueryHandler handler = new BasicQueryHandler(sqlHandler);
         2) Get the database support class, that is configured for the
            specific database used:
        SearchQueryHandler handler = mmbase.getDatabase();
         */

        // Queryhandler provided by databaselayer:
        SearchQueryHandler handler = mmbase.getDatabase();

        MMObjectBuilder pools = mmbase.getBuilder(&#34;pools&#34;);
        MMObjectBuilder images = mmbase.getBuilder(&#34;images&#34;);
        InsRel insrel = mmbase.getInsRel();

        // EXAMPLE 1: query retrieving real nodes (of type pools).
        NodeSearchQuery query1 = new NodeSearchQuery(pools);

/*
 Query equivalent to:
        SELECT * FROM &#60;basename&#62;_pools pools
 Returns:
    real nodes with these fields: number, otype, owner, name, description
 */
        System.out.println(&#34;Query: &#34; + sqlHandler.toSql(query1, sqlHandler));

        // Execute, get result as real nodes.
        List nodes1 = handler.getNodes(query1, pools);
        Iterator iNodes1 = nodes1.iterator();
        while (iNodes1.hasNext()) {
            MMObjectNode node = (MMObjectNode) iNodes1.next();
            System.out.println(&#34;Real node: &#34; + node);
        }

        // EXAMPLE 2: query retrieving clusternodes.
        BasicSearchQuery query2 = new BasicSearchQuery();
        BasicStep step2a = query2.addStep(pools);
        BasicRelationStep step2b = query2.addRelationStep(insrel, images);
        step2b.setDirectionality(RelationStep.DIRECTIONS_DESTINATION);
        Step step2c = step2b.getNext();
        // Add at least the number fields of all steps.
        query2.addField(step2a, pools.getField(&#34;number&#34;));
        query2.addField(step2b, insrel.getField(&#34;number&#34;));
        query2.addField(step2c, images.getField(&#34;number&#34;));

/*
 Query:
        SELECT
            pools.number,
            insrel.number,
            images.number
        FROM
            &#60;basename&#62;_pools pools,
            &#60;basename&#62;_insrel insrel,
            &#60;basename&#62;_images images
        WHERE (pools.number = insrel.snumber
        AND images.number = insrel.dnumber)
 */
        System.out.println(&#34;Query: &#34; + sqlHandler.toSql(query2, sqlHandler));

        // Execute, result as clusternodes.
        List nodes2 = handler.getNodes(query2, new ClusterBuilder(mmbase));
        Iterator iNodes2 = nodes2.iterator();
        while (iNodes2.hasNext()) {
            ClusterNode node = (ClusterNode) iNodes2.next();
            System.out.println(&#34;Clusternode: &#34; + node);
        }

/*
 Returns:
        clusternodes with these fields: pools.number, insrel.number, images.number
 */

        // EXAMPLE 3: query retrieving clusternodes using table aliases.
        BasicSearchQuery query3 = new BasicSearchQuery();
        BasicStep step3a = query3.addStep(pools);
        BasicRelationStep step3b = query3.addRelationStep(insrel, images);
        step3b.setDirectionality(RelationStep.DIRECTIONS_DESTINATION);
        BasicStep step3c = (BasicStep) step3b.getNext();
        // Set table aliases.
        step3a.setAlias(&#34;pools0&#34;);
        step3c.setAlias(&#34;images3&#34;);
        // Add at least the number fields of all steps.
        query3.addField(step3a, pools.getField(&#34;number&#34;));
        query3.addField(step3b, insrel.getField(&#34;number&#34;));
        query3.addField(step3c, images.getField(&#34;number&#34;));

/*
 Query:
        SELECT
            pools0.number,
            insrel.number,
            images3.number
        FROM
            &#60;basename&#62;_pools pools0,
            &#60;basename&#62;_insrel insrel,
            &#60;basename&#62;_images images3
        WHERE (pools0.number = insrel.snumber
        AND images3.number = insrel.dnumber)
 */
        System.out.println(&#34;Query: &#34; + sqlHandler.toSql(query3, sqlHandler));

        // Execute, result as clusternodes.
        List nodes3 = handler.getNodes(query3, new ClusterBuilder(mmbase));
        Iterator iNodes3 = nodes3.iterator();
        while (iNodes3.hasNext()) {
            ClusterNode node = (ClusterNode) iNodes3.next();
            System.out.println(&#34;Clusternode: &#34; + node);
        }

/*
 Returns:
        clusternodes with these fields: pools0.number, insrel.number, images3.number
 */

        // EXAMPLE 4: query retrieving resultnodes.
        BasicSearchQuery query4 = new BasicSearchQuery();
        BasicStep step4a = query4.addStep(pools);
        // Add some fields with field aliases.
        query4.addField(step4a, pools.getField(&#34;number&#34;)).setAlias(&#34;field1&#34;);
        query4.addField(step4a, pools.getField(&#34;name&#34;)).setAlias(&#34;field2&#34;);
        query4.addField(step4a, pools.getField(&#34;description&#34;)).setAlias(&#34;field3&#34;);

/*
 Query:
        SELECT
            number AS field1,
            name AS field2,
            description AS field3
        FROM
            &#60;basename&#62;_pools pools
 */
        System.out.println(&#34;Query: &#34; + sqlHandler.toSql(query4, sqlHandler));

        // Execute, result as resultnodes.
        List nodes4 = handler.getNodes(query4, new ResultBuilder(mmbase, query4));
        Iterator iNodes4 = nodes4.iterator();
        while (iNodes4.hasNext()) {
            ResultNode node = (ResultNode) iNodes4.next();
            System.out.println(&#34;Resultnode: &#34; + node);
        }

/*
 Returns:
        resultnodes with these fields: field1, field2, field3
 */

        // EXAMPLE 5: query retrieving aggregated resultnodes.
        BasicSearchQuery query5 = new BasicSearchQuery(true);
        BasicStep step5a = query5.addStep(pools);
        // Add some aggregated fields with field aliases.
        query5.addAggregatedField(step5a, pools.getField(&#34;number&#34;),
            AggregatedField.AGGREGATION_TYPE_COUNT).setAlias(&#34;pool_count&#34;);
        query5.addAggregatedField(step5a, pools.getField(&#34;number&#34;),
            AggregatedField.AGGREGATION_TYPE_MIN).setAlias(&#34;min_number&#34;);
        query5.addAggregatedField(step5a, pools.getField(&#34;number&#34;),
            AggregatedField.AGGREGATION_TYPE_MAX).setAlias(&#34;max_number&#34;);

/*
 Query:
        SELECT
            COUNT(number) AS pool_count,
            MIN(number) AS min_number,
            MAX(number) AS max_number
        FROM
            &#60;basename&#62;_pools pools
 */
        System.out.println(&#34;Query: &#34; + sqlHandler.toSql(query5, sqlHandler));

        // Execute, result as resultnodes.
        List nodes5 = handler.getNodes(query5, new ResultBuilder(mmbase, query5));
        Iterator iNodes5 = nodes5.iterator();
        while (iNodes5.hasNext()) {
            ResultNode node = (ResultNode) iNodes5.next();
            System.out.println(&#34;Resultnode: &#34; + node);
        }

/*
 Returns:
        a resultnode with these fields: pool_count, min_number, max_number
 */

        System.exit(0);
    }
}
</programlisting>
    </section>
  </section>
</article>