<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE principleset PUBLIC "//MMBase - principleset//" "http://www.mmbase.org/dtd/principleset_1_0.dtd">
<principleset name="MMBase" description="Principles for the MMBase Opensource project">
  <principle number="14">
    <state>active</state>
    <version>1.0</version>
    <theme>Software development, users, core, components, framework</theme>
    <name><![CDATA[The functionality of the MMBase core and its components should be built in the most generic and reusable way possible]]></name>
    <qualification><![CDATA[Strong rule]]></qualification>
    <explanation><![CDATA[]]></explanation>
    <argumentation><![CDATA[By following this principle, it becomes easier to reuse and expand existing components.]]></argumentation>
    <consequence><![CDATA[Developers and architects of MMBase projects (core/components) should take reusability into account throughout design and development.]]></consequence>
    <allowedimplementation><![CDATA[]]></allowedimplementation>
    <source><![CDATA[MMBase Technical Board]]></source>
  </principle>
  <principle number="13">
    <state>active</state>
    <version>1.0</version>
    <theme>Software development, performance, users, core, components, framework</theme>
    <name><![CDATA[The MMBase core and its components should demonstrate high-end performance on production environments. ]]></name>
    <qualification><![CDATA[Strong rule]]></qualification>
    <explanation><![CDATA[]]></explanation>
    <argumentation><![CDATA[Traditionally, development projects are focused on implementing functionality while ignoring issues of performance. This becomes more evident in situations of time pressure and tight deadlines. This can have undesirable side effects when it comes to performance, which should be avoided.]]></argumentation>
    <consequence><![CDATA[Developers and architects of MMBase projects (core/components) should take performance into account throughout developing or testing.
Ideally, MMBase projects should test the performance of their deliverables and provide the results of performance tests as part of the documentation.
If performance tests are absolutely not possible, MMBase projects should include in their documentation any available information about the behaviour of the application when it on comes to its performance in real-life situations.
]]></consequence>
    <allowedimplementation><![CDATA[Tools like Apache JMeter and JUnitPerf recommended for the testing of performance throughout the development lifecycle]]></allowedimplementation>
    <source><![CDATA[MMBase Technical Board]]></source>
  </principle>
  <principle number="12">
    <state>active</state>
    <version>1.0</version>
    <theme>Standards, Service, Components, Framework</theme>
    <name><![CDATA[MMBase applications communicate with each other only via the allowed Web Services protocols.]]></name>
    <qualification><![CDATA[Strong rule]]></qualification>
    <explanation><![CDATA[]]></explanation>
    <argumentation><![CDATA[A Web Services Layer as a means of exposing content is compliant with a Service Oriented Architecture. Once properly implemented, this architecture has many advantages. For example:
- Business driven development
- Better modularisation and exchangeability
]]></argumentation>
    <consequence><![CDATA[The communication between MMBase applications should go through the allowed Web Services protocol]]></consequence>
    <allowedimplementation><![CDATA[-	XML-RPC
-	SOAP
-	RMMCi
]]></allowedimplementation>
    <source><![CDATA[MMBase Technical Board]]></source>
  </principle>
  <principle number="11">
    <state>active</state>
    <version>1.0</version>
    <theme>All.
Core, framework, components
</theme>
    <name><![CDATA[MMBase is platform independent.]]></name>
    <qualification><![CDATA[Strong rule]]></qualification>
    <explanation><![CDATA[It should be possible to run MMBase implementations on different platforms. The fact that MMBase is written in Java, covers this principle per definition.]]></explanation>
    <argumentation><![CDATA[Following this principle makes it possible for MMBase implementations to run in heterogeneous environments. Using operating system specific functionalities has a negative effect on the portability of applications and components.]]></argumentation>
    <consequence><![CDATA[To run an MMBase-application, only a Java Virtual Machine (JVM) is necessary. A JVM is not dependent on operating systems. ]]></consequence>
    <allowedimplementation><![CDATA[Java]]></allowedimplementation>
    <source><![CDATA[MMBase Technical Board]]></source>
  </principle>
  <principle number="10">
    <state>active</state>
    <version>1.0</version>
    <theme>Core, framework, components</theme>
    <name><![CDATA[All source code of MMBase is subject to the Open Source licence MPL 1.0]]></name>
    <qualification><![CDATA[Binding]]></qualification>
    <explanation><![CDATA[The license chosen for MMBase at the release date (April 4, 2000) was the MPL 1.0. There are no plans to change the license.]]></explanation>
    <argumentation><![CDATA[The core of MMBase and the framework must have the same open source license to avoid license incompatibilities. 
For components that are developed for the MMBase-framework, or MMBase-portals, the MPL 1.0 is strongly advised, however, there might be reasons to use another license. In all cases this should not affect the license used for the core and framework. 
]]></argumentation>
    <consequence><![CDATA[Components or technology-solutions might be rejected because of incompatibility of licenses.]]></consequence>
    <allowedimplementation><![CDATA[MPL 1.0]]></allowedimplementation>
    <source><![CDATA[MMBase Technical Board]]></source>
  </principle>
  <principle number="9">
    <state>active</state>
    <version>1.0</version>
    <theme>Software development, components, core, framework</theme>
    <name><![CDATA[MMBase packages (core and components) should adhere to the principle of graceful degradation]]></name>
    <qualification><![CDATA[Strong rule]]></qualification>
    <explanation><![CDATA[Eventual degradation of the system should happen in such a manner that the system continues to operate, but provides a reduced level of service instead of failing completely.]]></explanation>
    <argumentation><![CDATA[Graceful degradation contributes to MMBase implementations that can be used in high-demand production environments and adds significantly to the availability and stability of the product.]]></argumentation>
    <consequence><![CDATA[Developers should implement the necessary classes, exceptions etc. in order to guarantee graceful degradation of the system for the part that they are building. Chosen solutions should be thoroughly tested. ]]></consequence>
    <allowedimplementation><![CDATA[]]></allowedimplementation>
    <source><![CDATA[MMBase Technical Board]]></source>
  </principle>
  <principle number="8">
    <state>active</state>
    <version>1.0</version>
    <theme>Software development, users, core, components, framework</theme>
    <name><![CDATA[The functionality of the MMBase core and its components should be built in the most generic and reusable way possible]]></name>
    <qualification><![CDATA[Strong rule]]></qualification>
    <explanation><![CDATA[]]></explanation>
    <argumentation><![CDATA[By following this principle, it becomes easier to reuse and expand existing components.]]></argumentation>
    <consequence><![CDATA[Developers and architects of MMBase projects (core/components) should take reusability into account throughout design and development.]]></consequence>
    <allowedimplementation><![CDATA[]]></allowedimplementation>
    <source><![CDATA[MMBase Technical Board]]></source>
  </principle>
  <principle number="7">
    <state>active</state>
    <version>1.0</version>
    <theme>Technical Architecture, Components</theme>
    <name><![CDATA[MMBase components should offer the maximum in flexibility during deployment]]></name>
    <qualification><![CDATA[Strong rule]]></qualification>
    <explanation><![CDATA[]]></explanation>
    <argumentation><![CDATA[]]></argumentation>
    <consequence><![CDATA[The deployment of MMBase components and implementations should be configurable in a way that allows the users to deploy only what they need. ]]></consequence>
    <allowedimplementation><![CDATA[Each component should adhere to the deployment rules of KARMA and Didactor. It must be possible to integrate components run-time.]]></allowedimplementation>
    <source><![CDATA[MMBase Technical Board]]></source>
  </principle>
  <principle number="6">
    <state>active</state>
    <version>1.0.1</version>
    <theme>Core</theme>
    <name><![CDATA[The core of MMBase should strive for the maximum in backwards compatibility throughout new releases.]]></name>
    <qualification><![CDATA[Strong rule]]></qualification>
    <explanation><![CDATA[]]></explanation>
    <argumentation><![CDATA[For the users is maintainability of the deployment very important. Backwards compatibility is not a holy grail but the core must be as stable as possible as far as code is concerned]]></argumentation>
    <consequence><![CDATA[Changes in the core should deal with issues of backwards compatibility. This can result to more development time. Furthermore, any changes that are not backwards compatible should be sufficiently documented. 
The documentation should contain explanations about changes that are not backwards compatible as well as advice on the impact on upgrades.
This principle also implies that the core must be as lean as possible. In this way it is possible to greatly avoid compatibility issues and the reworks that accompany them.
]]></consequence>
    <allowedimplementation><![CDATA[The database schema and the bridge must never be changed in a way that distorts their backwards compatibility.]]></allowedimplementation>
    <source><![CDATA[MMBase Technical Board]]></source>
  </principle>
  <principle number="6">
    <state>archived</state>
    <version>1.0</version>
    <theme></theme>
    <name><![CDATA[The core of MMBase should strive for the maximum in backwards compatibility throughout new releases.]]></name>
    <qualification><![CDATA[Strong rule]]></qualification>
    <explanation><![CDATA[]]></explanation>
    <argumentation><![CDATA[For the users is maintainability of the deployment very important. Backwards compatibility is not a holy grail but the core must be as stable as possible as far as code is concerned]]></argumentation>
    <consequence><![CDATA[Changes in the core should deal with issues of backwards compatibility. This can result to more development time. Furthermore, any changes that are not backwards compatible should be sufficiently documented. 
The documentation should contain explanations about changes that are not backwards compatible as well as advice on the impact on upgrades.
This principle also implies that the core must be as lean as possible. In this way it is possible to greatly avoid compatibility issues and the reworks that accompany them.
]]></consequence>
    <allowedimplementation><![CDATA[The database schema and the bridge must never be changed in a way that distorts their backwards compatibility.]]></allowedimplementation>
    <source><![CDATA[MMBase Technical Board]]></source>
  </principle>
  <principle number="4">
    <state>active</state>
    <version>1.0.5</version>
    <theme>Technical</theme>
    <name><![CDATA[Use the bridge]]></name>
    <qualification><![CDATA[Binding]]></qualification>
    <explanation><![CDATA[When using Java code to communicate to MMBase one should only use the bridge interfaces.]]></explanation>
    <argumentation><![CDATA[In this way you separate MMBase core code from your own code. This gives core developers more freedom. Your code is less prone to break on an update of MMBase. The bridge is a subset of all MMBase classes, so it is easier to use.

By using the bridge, you also automatically use MMBase security. We desire all exposed MMBase data to be subject to security.]]></argumentation>
    <consequence><![CDATA[The following classes from the org.mmbase package can be used (this list is maintained in
      the build script of RMMCI)
        org/mmbase/bridge/*
        org/mmbase/bridge/util/**
        org/mmbase/storage/search/*
        org/mmbase/datatypes/**
        org/mmbase/security/UserContext
        org/mmbase/security/AuthenticationData*
        org/mmbase/security/Rank
        org/mmbase/security/SecurityException.class

        org/mmbase/util/functions/**

        org/mmbase/cache/CachePolicy*
        org/mmbase/cache/Cache*

        org/mmbase/util/**
        /only if they themselves obey this principle

        org/mmbase/storage/Storable.class
        org/mmbase/storage/StorageException.class

        org/mmbase/core/util/Fields
        org/mmbase/core/*
        org/mmbase/core/event/**


]]></consequence>
    <allowedimplementation><![CDATA[Implementations can use the above classes. Normally they should leave instantiating the classes to the bridge - do not instantiate them through their constructors.]]></allowedimplementation>
    <source><![CDATA[]]></source>
  </principle>
  <principle number="4">
    <state>archived</state>
    <version>1.0.4</version>
    <theme>Technical</theme>
    <name><![CDATA[Use the bridge]]></name>
    <qualification><![CDATA[Binding]]></qualification>
    <explanation><![CDATA[When using Java code to communicate to MMBase one should only use the bridge interfaces.]]></explanation>
    <argumentation><![CDATA[In this way you separate MMBase core code from your own code. This gives core developers more freedom. Your code is less prone to break on an update of MMBase. The bridge is a subset of all MMBase classes, so it is easier to use.

By using the bridge, you also automatically use MMBase security. We desire all exposed MMBase data to be subject to security.]]></argumentation>
    <consequence><![CDATA[
]]></consequence>
    <allowedimplementation><![CDATA[]]></allowedimplementation>
    <source><![CDATA[]]></source>
  </principle>
  <principle number="5">
    <state>active</state>
    <version>1.0.2</version>
    <theme>Technical</theme>
    <name><![CDATA[Dependencies]]></name>
    <qualification><![CDATA[Binding]]></qualification>
    <explanation><![CDATA[Dependencies should be minimal, and preferably on already existings ones (no redundancy).]]></explanation>
    <argumentation><![CDATA[It is easier for people not to have to know about several mutually similar functionalities.]]></argumentation>
    <consequence><![CDATA[MMBase 1.8 depends on:

java 1.4

servlet api

backport-concurrency (dropped when migrating to java 1.5)

it's own logging framework (mapping to commons-logging, log4j, java logging exist)

xalan  (may be dropped when migrating to java 1.5)

commons-fileupload



Taglib also depends on: jstl.jar, standard.jar

Other known (optional) dependencies:
 imagemagick
 JAI
 activation and mail

You should not depend on libraries providing the same functionality.

Other dependencies can be introduced with reluctance and with good reason (e.g. several jakarta commons libraries, commons-collections, commons-validator etc)]]></consequence>
    <allowedimplementation><![CDATA[]]></allowedimplementation>
    <source><![CDATA[]]></source>
  </principle>
  <principle number="1">
    <state>archived</state>
    <version>1.0.1</version>
    <theme>Technical</theme>
    <name><![CDATA[Database independency]]></name>
    <qualification><![CDATA[Binding]]></qualification>
    <explanation><![CDATA[All code is implemented in a database independent way.]]></explanation>
    <argumentation><![CDATA[MMBase is principally indepent of the chosen database. 
So no code in MMBase should depend on features of a specific database (unless of course the code _is_ the specific database layer).

Therefore this is also a principle for applications built on MMBase, otherwise they are not portable to other MMBase installations.
]]></argumentation>
    <consequence><![CDATA[You should use the search-query frame-work to build queries, without falling back to 'legacy'
constraints.

You should not need JDBC-connections yourself, but if you do, use ((DatabaseStorageManager) MMBase.getStorageManager()).getConnection() - do not try to make your own connections nor
create your own database configuration - but leave that to MMBase.


You should also add an issue to the mmbase bugtracker to report the problem you try to circumvent.]]></consequence>
    <allowedimplementation><![CDATA[]]></allowedimplementation>
    <source><![CDATA[]]></source>
  </principle>
  <principle number="1">
    <state>active</state>
    <version>1.0.2</version>
    <theme>Technical</theme>
    <name><![CDATA[Database independency]]></name>
    <qualification><![CDATA[Binding]]></qualification>
    <explanation><![CDATA[All code is implemented in a database independent way.]]></explanation>
    <argumentation><![CDATA[MMBase is principally indepent of the chosen database. 
So no code in MMBase should depend on features of a specific database (unless of course the code _is_ the specific database layer).

Therefore this is also a principle for applications built on MMBase, otherwise they are not portable to other MMBase installations.
]]></argumentation>
    <consequence><![CDATA[You should use the search-query frame-work to build queries, without falling back to 'legacy'
constraints.

You should not need JDBC-connections yourself, but if you do, use ((DatabaseStorageManager) MMBase.getStorageManager()).getConnection() - do not try to make your own connections nor create your own database configuration - but leave that to MMBase.


You should also add an issue to the mmbase bugtracker to report the problem you try to circumvent.]]></consequence>
    <allowedimplementation><![CDATA[]]></allowedimplementation>
    <source><![CDATA[]]></source>
  </principle>
  <principle number="2">
    <state>archived</state>
    <version>1.0</version>
    <theme>Technical</theme>
    <name><![CDATA[Assume that you are in a servlet environment]]></name>
    <qualification><![CDATA[Binding]]></qualification>
    <explanation><![CDATA[Your Java code is not just java code, it is java code running in a servlet environment, so it may be subject to certain resctrictions while running.]]></explanation>
    <argumentation><![CDATA[]]></argumentation>
    <consequence><![CDATA[]]></consequence>
    <allowedimplementation><![CDATA[]]></allowedimplementation>
    <source><![CDATA[]]></source>
  </principle>
  <principle number="2">
    <state>archived</state>
    <version>1.0.1</version>
    <theme>Technical</theme>
    <name><![CDATA[Assume that you are in a servlet environment]]></name>
    <qualification><![CDATA[Binding]]></qualification>
    <explanation><![CDATA[Your Java code is not just java code, it is java code running in a servlet environment, so it may be subject to certain resctrictions while running.]]></explanation>
    <argumentation><![CDATA[Code is not optimally portable if no consideration is given to this principle.
]]></argumentation>
    <consequence><![CDATA[]]></consequence>
    <allowedimplementation><![CDATA[]]></allowedimplementation>
    <source><![CDATA[]]></source>
  </principle>
  <principle number="2">
    <state>active</state>
    <version>1.0.2</version>
    <theme>Technical</theme>
    <name><![CDATA[Assume that you are in a servlet environment]]></name>
    <qualification><![CDATA[Binding]]></qualification>
    <explanation><![CDATA[Your Java code is not just java code, it is java code running in a servlet environment, so it may be subject to certain resctrictions while running.]]></explanation>
    <argumentation><![CDATA[Code is not optimally portable if no consideration is given to this principle.
]]></argumentation>
    <consequence><![CDATA[Make no assumptions on the OS.

Make no assumptions on location or writeability of resources. To open resources (like configuration) you should use the MMBase ResourceLoader. 

Do not use java.io.File. 

The webapp may be installed as a 'war' and it's contents not available as File at all.

If a file-system is needed for some reason, the MMBase 'data directory' can be used, or use File.getTempFile().

Do not write anything to stdout, use the MMBase logging system. This can be configured to go to stdout if desired.]]></consequence>
    <allowedimplementation><![CDATA[]]></allowedimplementation>
    <source><![CDATA[]]></source>
  </principle>
  <principle number="3">
    <state>archived</state>
    <version>1.0</version>
    <theme></theme>
    <name><![CDATA[Code conventions]]></name>
    <qualification><![CDATA[Binding]]></qualification>
    <explanation><![CDATA[Code conventions make it easier and more comfortable to read and understand each others code.]]></explanation>
    <argumentation><![CDATA[When writing java, JSP or XML sources, you must take the MMBase Code Conventions into account.]]></argumentation>
    <consequence><![CDATA[When writing java, JSP or XML sources, you must take the MMBase Code Conventions into account.

Summary for java:

 Java code is indented by 4 spaces. Do not use tabs.
 Use SUN's code conventions. See link for MMBase specific conventions.

XML:

 XML code is indented by 2 spaces. Do not use tabs.

JSP:
        Preferably, JSP is like XML (e.g. JSPX). Java code in JSP should be limited to an absolute
        minimum. Use taglib (MMBase taglib, JSTL). Complicated functionality could be done in some
        MVC-framework, or be delegated to functions implemented on MMBase datatypes, fields, builders
        or function sets.
        A JSP should be short.  A few hunderd lines is much.
        Use includes, prefering dynamic includes (mm:include, jsp:include) over static includes
        (jsp:directive.include)

        Switch off the session <jsp:directive.page session="false" />, unless good reason for using the
        session exists.
]]></consequence>
    <allowedimplementation><![CDATA[]]></allowedimplementation>
    <source><![CDATA[]]></source>
  </principle>
  <principle number="3">
    <state>archived</state>
    <version>1.0.1</version>
    <theme></theme>
    <name><![CDATA[Code conventions]]></name>
    <qualification><![CDATA[Binding]]></qualification>
    <explanation><![CDATA[Code conventions make it easier and more comfortable to read and understand each others code.]]></explanation>
    <argumentation><![CDATA[When writing java, JSP or XML sources, you must take the MMBase Code Conventions into account.]]></argumentation>
    <consequence><![CDATA[When writing java, JSP or XML sources, you must take the MMBase Code Conventions into account.

Summary for java:

 Java code is indented by 4 spaces. Do not use tabs.
 Use SUN's code conventions. See link for MMBase specific conventions.

XML:

 XML code is indented by 2 spaces. Do not use tabs.

JSP:
        Preferably, JSP is like XML (e.g. JSPX). Java code in JSP should be limited to an absolute
        minimum. Use taglib (MMBase taglib, JSTL). Complicated functionality could be done in some
        MVC-framework, or be delegated to functions implemented on MMBase datatypes, fields, builders
        or function sets.
        A JSP should be short.  A few hunderd lines is much.
        Use includes, prefering dynamic includes (mm:include, jsp:include) over static includes
        (jsp:directive.include)

        Switch off the session <jsp:directive.page session="false" />, unless good reason for using the
        session exists.
        Make pages cacheable by a front-proxy, (e.g. by using mm:content), unless a good reason
        exists not to (then explicitely make it uncacheable, e.g. by using mm:content expires="0")

        Always use UTF-8 for the response.

        Preferred is (valid) XHTML Strict.

      Javascript:
        Like java.

      CSS:
        K&R, indent with 2 spaces.


]]></consequence>
    <allowedimplementation><![CDATA[]]></allowedimplementation>
    <source><![CDATA[]]></source>
  </principle>
  <principle number="3">
    <state>archived</state>
    <version>1.0.2</version>
    <theme></theme>
    <name><![CDATA[Code conventions]]></name>
    <qualification><![CDATA[Binding]]></qualification>
    <explanation><![CDATA[Code conventions make it easier and more comfortable to read and understand each others code.]]></explanation>
    <argumentation><![CDATA[When writing java, JSP or XML sources, you must take the MMBase Code Conventions into account.]]></argumentation>
    <consequence><![CDATA[When writing java, JSP or XML sources, you must take the MMBase Code Conventions into account.

Summary for java:

 Java code is indented by 4 spaces. Do not use tabs.
 Use SUN's code conventions. See link for MMBase specific conventions.

XML:

 XML code is indented by 2 spaces. Do not use tabs.

JSP:
 Preferably, JSP is like XML (e.g. JSPX). Java code in JSP should be limited to an absolute minimum. Use taglib (MMBase taglib, JSTL). 

 Complicated functionality could be done in some MVC-framework, or be delegated to functions implemented on MMBase datatypes, fields, builders or function sets.


 A JSP should be short.  A few hunderd lines is much.

 Use includes, prefering dynamic includes (mm:include, jsp:include) over static include (jsp:directive.include)

 Switch off the session <jsp:directive.page session="false" />, unless good reason for using the session exists.

 Make pages cacheable by a front-proxy, (e.g. by using mm:content), unless a good reason exists not to (then explicitely make it uncacheable, e.g. by using mm:content expires="0")

Always use UTF-8 for the response.

 Preferred is (valid) XHTML Strict.

Javascript:
 Like java.

CSS:
 K&R, indent with 2 spaces.


]]></consequence>
    <allowedimplementation><![CDATA[Code wich obeys the conventions.]]></allowedimplementation>
    <source><![CDATA[]]></source>
  </principle>
  <principle number="3">
    <state>active</state>
    <version>1.0.3</version>
    <theme></theme>
    <name><![CDATA[Code conventions]]></name>
    <qualification><![CDATA[Binding]]></qualification>
    <explanation><![CDATA[Code conventions make it easier and more comfortable to read and understand each others code.]]></explanation>
    <argumentation><![CDATA[When writing java, JSP or XML sources, you must take the MMBase Code Conventions into account.]]></argumentation>
    <consequence><![CDATA[When writing java, JSP or XML sources, you must take the MMBase Code Conventions into account.

Summary for java:

 Java code is indented by 4 spaces. Do not use tabs.
 Use SUN's code conventions. See link for MMBase specific conventions.

XML:

 XML code is indented by 2 spaces. Do not use tabs.

JSP:
 Preferably, JSP is like XML (e.g. JSPX). Java code in JSP should be limited to an absolute minimum. Use taglib (MMBase taglib, JSTL). 

 Complicated functionality could be done in some MVC-framework, or be delegated to functions implemented on MMBase datatypes, fields, builders or function sets.


 A JSP should be short.  A few hunderd lines is much.

 Use includes, prefering dynamic includes (mm:include, jsp:include) over static include (jsp:directive.include)

 Switch off the session <jsp:directive.page session="false" />, unless good reason for using the session exists.

 Make pages cacheable by a front-proxy, (e.g. by using mm:content), unless a good reason exists not to (then explicitely make it uncacheable, e.g. by using mm:content expires="0")

Always use UTF-8 for the response.

 Preferred is (valid) XHTML Strict.

Javascript:
 Like java.

CSS:
 K&R, indent with 2 spaces.


]]></consequence>
    <allowedimplementation><![CDATA[Code wich obeys the conventions.]]></allowedimplementation>
    <source><![CDATA[]]></source>
  </principle>
  <principle number="4">
    <state>archived</state>
    <version>1.0</version>
    <theme></theme>
    <name><![CDATA[Use the bridge]]></name>
    <qualification><![CDATA[Binding]]></qualification>
    <explanation><![CDATA[]]></explanation>
    <argumentation><![CDATA[]]></argumentation>
    <consequence><![CDATA[]]></consequence>
    <allowedimplementation><![CDATA[]]></allowedimplementation>
    <source><![CDATA[]]></source>
  </principle>
  <principle number="5">
    <state>archived</state>
    <version>1.0</version>
    <theme></theme>
    <name><![CDATA[Dependencies]]></name>
    <qualification><![CDATA[Binding]]></qualification>
    <explanation><![CDATA[]]></explanation>
    <argumentation><![CDATA[]]></argumentation>
    <consequence><![CDATA[]]></consequence>
    <allowedimplementation><![CDATA[]]></allowedimplementation>
    <source><![CDATA[]]></source>
  </principle>
  <principle number="4">
    <state>archived</state>
    <version>1.0.1</version>
    <theme>Technical</theme>
    <name><![CDATA[Use the bridge]]></name>
    <qualification><![CDATA[Binding]]></qualification>
    <explanation><![CDATA[Dependencies should be minimal, and preferably on already existings ones (no redundancy).]]></explanation>
    <argumentation><![CDATA[It is easier for people not to have to know about several mutually similar functionalities.]]></argumentation>
    <consequence><![CDATA[MMBase 1.8 depends on:

java 1.4

servlet api

backport-concurrency (dropped when migrating to java 1.5)

it's own logging framework (mapping to commons-logging, log4j, java logging exist)

xalan  (may be dropped when migrating to java 1.5)

commons-fileupload

Taglib also depends on: jstl.jar, standard.jar

Other known (optional) dependencies:
 imagemagick
 JAI
 activation and mail

You should not depend on libraries providing the same functionality.

Other dependencies can be introduced with reluctance and with good reason (e.g. several jakarta commons libraries, commons-collections, commons-validator etc)

]]></consequence>
    <allowedimplementation><![CDATA[]]></allowedimplementation>
    <source><![CDATA[]]></source>
  </principle>
  <principle number="4">
    <state>archived</state>
    <version>1.0.2</version>
    <theme>Technical</theme>
    <name><![CDATA[Use the bridge]]></name>
    <qualification><![CDATA[Binding]]></qualification>
    <explanation><![CDATA[Dependencies should be minimal, and preferably on already existings ones (no redundancy).]]></explanation>
    <argumentation><![CDATA[It is easier for people not to have to know about several mutually similar functionalities.]]></argumentation>
    <consequence><![CDATA[MMBase 1.8 depends on:

java 1.4

servlet api

backport-concurrency (dropped when migrating to java 1.5)

it's own logging framework (mapping to commons-logging, log4j, java logging exist)

xalan  (may be dropped when migrating to java 1.5)

commons-fileupload



Taglib also depends on: jstl.jar, standard.jar

Other known (optional) dependencies:
 imagemagick
 JAI
 activation and mail

You should not depend on libraries providing the same functionality.

Other dependencies can be introduced with reluctance and with good reason (e.g. several jakarta commons libraries, commons-collections, commons-validator etc)

]]></consequence>
    <allowedimplementation><![CDATA[]]></allowedimplementation>
    <source><![CDATA[]]></source>
  </principle>
  <principle number="4">
    <state>archived</state>
    <version>1.0.3</version>
    <theme>Technical</theme>
    <name><![CDATA[Use the bridge]]></name>
    <qualification><![CDATA[Binding]]></qualification>
    <explanation><![CDATA[Dependencies should be minimal, and preferably on already existings ones (no redundancy).]]></explanation>
    <argumentation><![CDATA[It is easier for people not to have to know about several mutually similar functionalities.]]></argumentation>
    <consequence><![CDATA[

]]></consequence>
    <allowedimplementation><![CDATA[]]></allowedimplementation>
    <source><![CDATA[]]></source>
  </principle>
  <principle number="5">
    <state>archived</state>
    <version>1.0.1</version>
    <theme></theme>
    <name><![CDATA[Dependencies]]></name>
    <qualification><![CDATA[Binding]]></qualification>
    <explanation><![CDATA[]]></explanation>
    <argumentation><![CDATA[]]></argumentation>
    <consequence><![CDATA[MMBase 1.8 depends on:

java 1.4

servlet api

backport-concurrency (dropped when migrating to java 1.5)

it's own logging framework (mapping to commons-logging, log4j, java logging exist)

xalan  (may be dropped when migrating to java 1.5)

commons-fileupload



Taglib also depends on: jstl.jar, standard.jar

Other known (optional) dependencies:
 imagemagick
 JAI
 activation and mail

You should not depend on libraries providing the same functionality.

Other dependencies can be introduced with reluctance and with good reason (e.g. several jakarta commons libraries, commons-collections, commons-validator etc)]]></consequence>
    <allowedimplementation><![CDATA[]]></allowedimplementation>
    <source><![CDATA[]]></source>
  </principle>
  <principle number="1">
    <state>archived</state>
    <version>1.0</version>
    <theme>Technical</theme>
    <name><![CDATA[Database independency]]></name>
    <qualification><![CDATA[Binding]]></qualification>
    <explanation><![CDATA[All code is implemented in a database independent way.]]></explanation>
    <argumentation><![CDATA[MMBase is principally indepent of the chosen database. So no code in MMBase should depend on
      features of a specific database (unless of course the code _is_ the specific database layer).
      Therefore this is also a principle for applications built on MMBase, otherwise they are not
      portable to other MMBase installations.
]]></argumentation>
    <consequence><![CDATA[You should use the search-query frame-work to build queries, without falling back to 'legacy'
constraints.

You should not need JDBC-connections yourself, but if you do, use ((DatabaseStorageManager)
MMBase.getStorageManager()).getConnection() - do not try to make your own connections nor
create your own database configuration - but leave that to MMBase.


You should also add an issue to the mmbase bugtracker to report the problem you try to circumvent.]]></consequence>
    <allowedimplementation><![CDATA[]]></allowedimplementation>
    <source><![CDATA[]]></source>
  </principle>
</principleset>
